---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/Orbit.Application/Orbit.Application.csproj
  - src/Orbit.Application/Behaviors/ValidationBehavior.cs
  - src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs
  - src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs
  - src/Orbit.Application/Auth/Validators/RegisterCommandValidator.cs
  - src/Orbit.Application/Auth/Validators/LoginQueryValidator.cs
  - src/Orbit.Api/Middleware/ValidationExceptionHandler.cs
  - src/Orbit.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "API requests with invalid input return structured validation errors before reaching command/query handlers"
    - "Valid requests pass through the validation pipeline unmodified to handlers"
    - "Requests without validators pass through the pipeline without error"
  artifacts:
    - path: "src/Orbit.Application/Behaviors/ValidationBehavior.cs"
      provides: "MediatR pipeline behavior that runs FluentValidation validators"
      contains: "IPipelineBehavior"
    - path: "src/Orbit.Api/Middleware/ValidationExceptionHandler.cs"
      provides: "IExceptionHandler that catches ValidationException and returns 400 with structured errors"
      contains: "IExceptionHandler"
    - path: "src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs"
      provides: "Validation rules for CreateHabitCommand"
      contains: "AbstractValidator<CreateHabitCommand>"
    - path: "src/Orbit.Application/Auth/Validators/RegisterCommandValidator.cs"
      provides: "Validation rules for RegisterCommand"
      contains: "AbstractValidator<RegisterCommand>"
  key_links:
    - from: "src/Orbit.Api/Program.cs"
      to: "src/Orbit.Application/Behaviors/ValidationBehavior.cs"
      via: "MediatR pipeline behavior registration"
      pattern: "AddOpenBehavior.*ValidationBehavior"
    - from: "src/Orbit.Application/Behaviors/ValidationBehavior.cs"
      to: "FluentValidation.IValidator"
      via: "IEnumerable<IValidator<TRequest>> injection"
      pattern: "IEnumerable<IValidator<TRequest>>"
    - from: "src/Orbit.Api/Program.cs"
      to: "src/Orbit.Api/Middleware/ValidationExceptionHandler.cs"
      via: "AddExceptionHandler DI registration"
      pattern: "AddExceptionHandler<ValidationExceptionHandler>"
---

<objective>
Add request validation via FluentValidation integrated into the MediatR pipeline, so invalid API input returns structured 400 errors before reaching any command/query handler.

Purpose: Centralizes input validation in the CQRS pipeline rather than scattering it across handlers. Invalid requests are rejected with field-level error messages, improving API reliability and developer experience.

Output: ValidationBehavior pipeline, ValidationExceptionHandler middleware, and validators for all existing commands/queries that accept user input.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md

Key source files:
@src/Orbit.Api/Program.cs
@src/Orbit.Application/Orbit.Application.csproj
@src/Orbit.Application/Habits/Commands/CreateHabitCommand.cs
@src/Orbit.Application/Habits/Commands/LogHabitCommand.cs
@src/Orbit.Application/Auth/Commands/RegisterCommand.cs
@src/Orbit.Application/Auth/Queries/LoginQuery.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: FluentValidation packages + ValidationBehavior + ValidationExceptionHandler</name>
  <files>
    src/Orbit.Application/Orbit.Application.csproj
    src/Orbit.Application/Behaviors/ValidationBehavior.cs
    src/Orbit.Api/Middleware/ValidationExceptionHandler.cs
  </files>
  <action>
    **Step 1: Add FluentValidation packages**

    ```
    dotnet add src/Orbit.Application/Orbit.Application.csproj package FluentValidation --version 12.1.1
    dotnet add src/Orbit.Application/Orbit.Application.csproj package FluentValidation.DependencyInjectionExtensions --version 12.1.1
    ```

    **Step 2: Create ValidationBehavior**

    Create `src/Orbit.Application/Behaviors/ValidationBehavior.cs`:
    - Namespace: `Orbit.Application.Behaviors`
    - Class: `public sealed class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : class`
    - Inject `IEnumerable<IValidator<TRequest>> validators` via primary constructor
    - In `Handle`:
      1. If `!validators.Any()`, call `return await next()` immediately (short-circuit for requests without validators)
      2. Create `new ValidationContext<TRequest>(request)`
      3. Run all validators in parallel: `await Task.WhenAll(validators.Select(v => v.ValidateAsync(context, cancellationToken)))`
      4. Collect failures: `validationResults.SelectMany(r => r.Errors).Where(f => f is not null).ToList()`
      5. If `failures.Count != 0`, throw `new ValidationException(failures)` (FluentValidation.ValidationException)
      6. Otherwise, `return await next()`

    See research RESEARCH.md "Pattern 1" for the exact implementation.

    **Step 3: Create ValidationExceptionHandler**

    Create `src/Orbit.Api/Middleware/ValidationExceptionHandler.cs`:
    - Namespace: `Orbit.Api.Middleware`
    - Class: `internal sealed class ValidationExceptionHandler : IExceptionHandler`
    - In `TryHandleAsync`:
      1. Check if `exception is not FluentValidation.ValidationException validationException` -- if not, return `false`
      2. Set `httpContext.Response.StatusCode = StatusCodes.Status400BadRequest`
      3. Group errors by `PropertyName` into a dictionary of `string -> string[]`
      4. Write JSON response: `{ "type": "ValidationFailure", "status": 400, "errors": { ... } }`
      5. Return `true`

    See research RESEARCH.md "Pattern 2" for the exact implementation.
  </action>
  <verify>
    1. `dotnet build Orbit.slnx` succeeds
    2. `ValidationBehavior.cs` exists at `src/Orbit.Application/Behaviors/` and implements `IPipelineBehavior`
    3. `ValidationExceptionHandler.cs` exists at `src/Orbit.Api/Middleware/` and implements `IExceptionHandler`
    4. FluentValidation 12.1.1 is in `Orbit.Application.csproj`
  </verify>
  <done>
    FluentValidation packages installed. ValidationBehavior pipeline behavior created. ValidationExceptionHandler middleware created. Both compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validators + register in DI</name>
  <files>
    src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs
    src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs
    src/Orbit.Application/Auth/Validators/RegisterCommandValidator.cs
    src/Orbit.Application/Auth/Validators/LoginQueryValidator.cs
    src/Orbit.Api/Program.cs
  </files>
  <action>
    **Step 1: Create CreateHabitCommandValidator**

    Create `src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs`:
    - Namespace: `Orbit.Application.Habits.Validators`
    - Extends `AbstractValidator<CreateHabitCommand>`
    - Rules:
      - `UserId` -- NotEmpty
      - `Title` -- NotEmpty, MaximumLength(200)
      - `FrequencyQuantity` -- GreaterThan(0)
      - `Days` -- When Days is not null and not empty, FrequencyQuantity must equal 1 (with message "Days can only be specified when frequency quantity is 1")
      - `Unit` -- NotEmpty when `Type == HabitType.Quantifiable` (with message "Unit is required for quantifiable habits")

    **Step 2: Create LogHabitCommandValidator**

    Create `src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs`:
    - Namespace: `Orbit.Application.Habits.Validators`
    - Extends `AbstractValidator<LogHabitCommand>`
    - Rules:
      - `UserId` -- NotEmpty
      - `HabitId` -- NotEmpty
      - `Value` -- GreaterThan(0) when Value.HasValue (with message "Log value must be positive")

    **Step 3: Create RegisterCommandValidator**

    Create `src/Orbit.Application/Auth/Validators/RegisterCommandValidator.cs`:
    - Namespace: `Orbit.Application.Auth.Validators`
    - Extends `AbstractValidator<RegisterCommand>`
    - Rules:
      - `Name` -- NotEmpty, MaximumLength(100)
      - `Email` -- NotEmpty, EmailAddress
      - `Password` -- NotEmpty, MinimumLength(8)
    - Note: Domain entity `User.Create()` also validates password complexity (uppercase, lowercase, digit). The FluentValidation rules handle input-level validation (presence, format, length). These are complementary -- FluentValidation catches obviously bad input before it reaches the domain.

    **Step 4: Create LoginQueryValidator**

    Create `src/Orbit.Application/Auth/Validators/LoginQueryValidator.cs`:
    - Namespace: `Orbit.Application.Auth.Validators`
    - Extends `AbstractValidator<LoginQuery>`
    - Rules:
      - `Email` -- NotEmpty, EmailAddress
      - `Password` -- NotEmpty

    **Step 5: Register in Program.cs DI**

    In `src/Orbit.Api/Program.cs`, add the following registrations. These changes go near the existing MediatR registration:

    1. Add `using Orbit.Api.Middleware;` at the top
    2. Add validator registration BEFORE the MediatR registration:
       ```csharp
       builder.Services.AddValidatorsFromAssemblyContaining<CreateHabitCommandValidator>();
       ```
       Add `using FluentValidation;` and `using Orbit.Application.Habits.Validators;` for this.

    3. Update the MediatR registration to include the validation behavior:
       ```csharp
       builder.Services.AddMediatR(cfg =>
       {
           cfg.RegisterServicesFromAssembly(typeof(Orbit.Application.Chat.Commands.ProcessUserChatCommand).Assembly);
           cfg.AddOpenBehavior(typeof(ValidationBehavior<,>));
       });
       ```
       Add `using Orbit.Application.Behaviors;` for `ValidationBehavior`.

    4. Add exception handler registration (after `builder.Services.AddControllers()`):
       ```csharp
       builder.Services.AddExceptionHandler<ValidationExceptionHandler>();
       builder.Services.AddProblemDetails();
       ```

    5. Add exception handler to middleware pipeline (BEFORE `app.UseHttpsRedirection()`):
       ```csharp
       app.UseExceptionHandler();
       ```

    IMPORTANT: Do NOT use the `FluentValidation.AspNetCore` package -- it is deprecated. The MediatR `IPipelineBehavior` approach is the correct integration point.
  </action>
  <verify>
    1. `dotnet build Orbit.slnx` succeeds with no errors
    2. All 4 validator files exist in their respective directories
    3. Program.cs contains `AddValidatorsFromAssembly`, `AddOpenBehavior(typeof(ValidationBehavior<,>))`, `AddExceptionHandler<ValidationExceptionHandler>`, `AddProblemDetails`, `UseExceptionHandler`
    4. Run `dotnet run --project src/Orbit.Api` to confirm startup succeeds
    5. Test validation with curl (if API is running):
       - `curl -X POST http://localhost:5000/api/auth/register -H "Content-Type: application/json" -d '{"name":"","email":"bad","password":""}' ` should return 400 with structured validation errors
       - `curl -X POST http://localhost:5000/api/auth/login -H "Content-Type: application/json" -d '{"email":"","password":""}' ` should return 400
  </verify>
  <done>
    Four validators created (CreateHabitCommand, LogHabitCommand, RegisterCommand, LoginQuery). ValidationBehavior registered as MediatR pipeline behavior. ValidationExceptionHandler registered as global exception handler. Invalid input returns structured 400 responses with field-level errors. Valid input passes through to handlers unchanged.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Orbit.slnx` -- clean build
2. Send invalid RegisterCommand (empty name/email/password) -- returns 400 with `{ "type": "ValidationFailure", "status": 400, "errors": { "Name": [...], "Email": [...], "Password": [...] } }`
3. Send valid RegisterCommand -- returns 200 (validation passes through to handler)
4. Send invalid CreateHabitCommand (empty title, frequency quantity 0) -- returns 400 with structured errors
5. Send valid LoginQuery -- returns 200 or 401 (from handler, not validation)
6. ProcessUserChatCommand (no validator) -- passes through pipeline without error (the `!validators.Any()` short-circuit)
</verification>

<success_criteria>
- FluentValidation 12.1.1 installed in Orbit.Application
- ValidationBehavior runs before all MediatR handlers
- ValidationExceptionHandler catches FluentValidation.ValidationException and returns structured 400
- All 4 validators enforce input rules
- Requests without validators (e.g., ProcessUserChatCommand, GetHabitsQuery) pass through unaffected
- No manual validation added to controllers
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`
</output>
