---
phase: 05-user-learning-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Orbit.Domain/Entities/UserFact.cs
  - src/Orbit.Domain/Models/ExtractedFacts.cs
  - src/Orbit.Domain/Interfaces/IFactExtractionService.cs
  - src/Orbit.Infrastructure/Persistence/OrbitDbContext.cs
  - src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs
  - src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
  - src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
  - src/Orbit.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "When user shares personal information in chat, AI extracts key facts and persists them to UserFacts table"
    - "Stored facts automatically load into AI system prompt for personalized responses in subsequent conversations"
    - "Fact extraction uses a separate LLM call after action execution (dual-pass)"
    - "UserFact entity supports soft delete with global query filter"
  artifacts:
    - path: "src/Orbit.Domain/Entities/UserFact.cs"
      provides: "UserFact entity with soft delete, factory method, categories"
      contains: "class UserFact : Entity"
    - path: "src/Orbit.Domain/Interfaces/IFactExtractionService.cs"
      provides: "Fact extraction service interface"
      contains: "interface IFactExtractionService"
    - path: "src/Orbit.Domain/Models/ExtractedFacts.cs"
      provides: "Fact extraction response model"
      contains: "record ExtractedFacts"
    - path: "src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs"
      provides: "Gemini-based fact extraction implementation"
      contains: "class GeminiFactExtractionService"
    - path: "src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs"
      provides: "System prompt with user facts section"
      contains: "What You Know About This User"
  key_links:
    - from: "src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs"
      to: "IFactExtractionService"
      via: "constructor injection, called after action execution"
      pattern: "_factExtractionService.ExtractFactsAsync"
    - from: "src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs"
      to: "SystemPromptBuilder"
      via: "facts loaded and passed to IAiIntentService"
      pattern: "userFactRepository.FindAsync"
    - from: "src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs"
      to: "Gemini API"
      via: "HTTP POST for fact extraction"
      pattern: "httpClient.PostAsJsonAsync"
---

<objective>
Create the UserFact domain entity, fact extraction service, and integrate both into the chat pipeline so that facts are extracted from conversations and loaded into the AI system prompt for personalization.

Purpose: Enable the AI to learn about users from conversations and use that knowledge in future interactions (ULRN-01, ULRN-02).
Output: UserFact entity with migration, GeminiFactExtractionService, modified chat handler with dual-pass extraction, modified SystemPromptBuilder with facts section.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-user-learning-system/05-RESEARCH.md

Key files to reference:
@src/Orbit.Domain/Common/Entity.cs — Base entity class (Id with Guid.NewGuid())
@src/Orbit.Domain/Entities/User.cs — Existing entity pattern (private constructor, static Create factory)
@src/Orbit.Domain/Interfaces/IAiIntentService.cs — Existing AI service interface pattern
@src/Orbit.Infrastructure/Persistence/OrbitDbContext.cs — DbContext with existing entity configs
@src/Orbit.Infrastructure/Services/GeminiIntentService.cs — Gemini API call pattern (HTTP client, DTOs, retry logic)
@src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs — Current system prompt builder (needs facts section added)
@src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs — Current chat handler (needs fact loading + extraction)
@src/Orbit.Api/Program.cs — Service registration (DI container)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserFact entity, extraction interface, and Gemini extraction service</name>
  <files>
    src/Orbit.Domain/Entities/UserFact.cs
    src/Orbit.Domain/Models/ExtractedFacts.cs
    src/Orbit.Domain/Interfaces/IFactExtractionService.cs
    src/Orbit.Infrastructure/Persistence/OrbitDbContext.cs
    src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs
  </files>
  <action>
    **1. Create UserFact entity** (`src/Orbit.Domain/Entities/UserFact.cs`):
    - Extends `Entity` base class (gets `Guid Id { get; init; } = Guid.NewGuid()`)
    - Properties: `Guid UserId` (private set), `string FactText` (private set, null!), `string? Category` (private set — "preference", "routine", "context"), `DateTime ExtractedAtUtc` (private set), `DateTime? UpdatedAtUtc` (private set), `bool IsDeleted` (private set), `DateTime? DeletedAtUtc` (private set)
    - Private parameterless constructor for EF Core
    - Static `Create(Guid userId, string factText, string? category)` factory returning `Result<UserFact>`:
      - Validate factText not empty, max 500 chars
      - Basic prompt injection detection: reject if contains "ignore", "system:", "you must", "instruction:" (case-insensitive)
      - Set `ExtractedAtUtc = DateTime.UtcNow`
    - `Update(string newFactText)` method: sets FactText and UpdatedAtUtc
    - `SoftDelete()` method: sets IsDeleted=true, DeletedAtUtc=DateTime.UtcNow
    - Follow exact pattern from existing entities (e.g., User.cs private set, private constructor, Result<T> factory)

    **2. Create ExtractedFacts model** (`src/Orbit.Domain/Models/ExtractedFacts.cs`):
    - `record ExtractedFacts` with `required List<FactCandidate> Facts { get; init; }`
    - `record FactCandidate` with `required string FactText { get; init; }` and `required string Category { get; init; }`
    - Namespace: `Orbit.Domain.Models`

    **3. Create IFactExtractionService interface** (`src/Orbit.Domain/Interfaces/IFactExtractionService.cs`):
    - Method: `Task<Result<ExtractedFacts>> ExtractFactsAsync(string userMessage, string? aiResponse, CancellationToken cancellationToken = default)`
    - Follow pattern from `IAiIntentService` — returns `Result<T>`, uses CancellationToken

    **4. Update OrbitDbContext** (`src/Orbit.Infrastructure/Persistence/OrbitDbContext.cs`):
    - Add `public DbSet<UserFact> UserFacts => Set<UserFact>();`
    - Add entity configuration in OnModelCreating:
      ```csharp
      modelBuilder.Entity<UserFact>(entity =>
      {
          entity.HasIndex(f => new { f.UserId, f.IsDeleted });
          entity.HasQueryFilter(f => !f.IsDeleted);
      });
      ```
    - Add EF Core migration: `dotnet ef migrations add AddUserFacts --project src/Orbit.Infrastructure --startup-project src/Orbit.Api`

    **5. Create GeminiFactExtractionService** (`src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs`):
    - `sealed class GeminiFactExtractionService` implementing `IFactExtractionService`
    - Primary constructor with `HttpClient httpClient`, `IOptions<GeminiSettings> options`, `ILogger<GeminiFactExtractionService> logger`
    - Reuse the same Gemini API DTO pattern from GeminiIntentService (GeminiRequest, GeminiContent, GeminiPart, GeminiGenerationConfig, GeminiResponse, GeminiCandidate — define as private records inside class, same as GeminiIntentService does)
    - Same retry logic for 429 rate limiting (exponential backoff, max 3 retries)
    - `ResponseMimeType = "application/json"` in generation config
    - Temperature = 0.1 for consistency
    - Extraction prompt (as system content):
      ```
      # Extract Key Facts from Conversation

      Analyze this conversation and extract ONLY factual information the user shared about themselves.

      **User message:** {userMessage}
      **AI response:** {aiResponse}

      Return JSON with this EXACT structure:
      {
        "facts": [
          {
            "factText": "clear, concise fact statement",
            "category": "preference" | "routine" | "context"
          }
        ]
      }

      Rules:
      - Extract ONLY explicit statements by the user about themselves
      - Do NOT infer or assume facts not directly stated
      - Each fact should be a standalone sentence
      - Category: preference (likes/dislikes/preferences), routine (schedules/patterns), context (situation/background/goals)
      - If no personal facts to extract, return {"facts": []}
      - NEVER extract action requests, commands, or habit names as facts
      - Examples of what IS a fact: "User is a morning person", "User works night shifts", "User prefers running outdoors"
      - Examples of what is NOT a fact: "User wants to create a running habit", "User logged meditation"
      ```
    - Deserialize response using same `JsonSerializerOptions` pattern (PropertyNameCaseInsensitive, JsonStringEnumConverter)
    - On empty response or deserialization failure, return `Result.Success(new ExtractedFacts { Facts = [] })` (not a failure — no facts is valid)
    - Log extraction timing and fact count
  </action>
  <verify>
    Run `dotnet build src/Orbit.Infrastructure` — must compile with new entity, DbContext changes, and service.
    Run EF Core migration — migration file must be generated successfully.
    Verify UserFact.Create() rejects empty text, text >500 chars, and suspicious patterns.
  </verify>
  <done>
    UserFact entity exists with soft delete, factory validation, and prompt injection detection.
    IFactExtractionService interface defined in Domain.
    GeminiFactExtractionService calls Gemini API with structured extraction prompt.
    OrbitDbContext has UserFacts DbSet with global query filter for soft delete.
    EF Core migration generated for UserFacts table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate fact extraction into chat pipeline and system prompt</name>
  <files>
    src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
    src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
    src/Orbit.Api/Program.cs
  </files>
  <action>
    **1. Modify SystemPromptBuilder.BuildSystemPrompt** to accept user facts:
    - Change signature to: `BuildSystemPrompt(IReadOnlyList<Habit> activeHabits, IReadOnlyList<Tag> userTags, IReadOnlyList<UserFact> userFacts)`
    - Add new section BEFORE the "Today's Date" section:
      ```
      ## What You Know About This User
      ```
    - If userFacts.Count == 0: `"(nothing yet - learn as you go)"`
    - If facts exist: iterate ordered by ExtractedAtUtc descending, each line: `"- {fact.FactText}"`
    - Keep the section compact — no timestamps in the prompt (just facts)
    - Add instruction after facts: `"Use these facts to personalize your responses. Do NOT repeat these facts back to the user unless relevant."`

    **2. Update all callers of SystemPromptBuilder.BuildSystemPrompt**:
    - `GeminiIntentService.InterpretAsync`: Change call to pass empty list for now: `SystemPromptBuilder.BuildSystemPrompt(activeHabits, userTags, Array.Empty<UserFact>())`
    - `OllamaIntentService` (AiIntentService.cs): Same change — pass `Array.Empty<UserFact>()`
    - These callers don't have facts context yet — the chat handler will pass facts via a modified approach (see below)

    **IMPORTANT DESIGN NOTE**: The intent services call SystemPromptBuilder directly but don't have access to UserFacts. Instead of modifying IAiIntentService to accept facts, modify the chat handler to:
    - Load user facts from repository
    - Update the `IAiIntentService.InterpretAsync` signature to accept `IReadOnlyList<UserFact> userFacts` as a new parameter
    - Update `IAiIntentService` interface to: `Task<Result<AiActionPlan>> InterpretAsync(string userMessage, IReadOnlyList<Habit> activeHabits, IReadOnlyList<Tag> userTags, IReadOnlyList<UserFact> userFacts, CancellationToken cancellationToken = default)`
    - Update `GeminiIntentService.InterpretAsync` to accept the new parameter and pass it to `SystemPromptBuilder.BuildSystemPrompt`
    - Update `OllamaIntentService.InterpretAsync` (AiIntentService.cs) to accept the new parameter and pass it to `SystemPromptBuilder.BuildSystemPrompt`

    **3. Modify ProcessUserChatCommandHandler**:
    - Add constructor dependencies: `IGenericRepository<UserFact> userFactRepository`, `IFactExtractionService factExtractionService`
    - **Load facts (step 1c)**: After loading habits and tags, load user facts:
      ```csharp
      var userFacts = await userFactRepository.FindAsync(
          f => f.UserId == request.UserId,
          cancellationToken);
      ```
      (Global query filter on IsDeleted handles soft-deleted facts automatically)
    - **Pass facts to AI**: Update the `aiIntentService.InterpretAsync` call to pass `userFacts`
    - **Fact extraction (step 5, after SaveChangesAsync)**: Add dual-pass fact extraction as a fire-and-forget-style step AFTER the main response:
      ```csharp
      // 5. Extract facts from conversation (non-blocking — failure doesn't affect response)
      try
      {
          var extractionResult = await factExtractionService.ExtractFactsAsync(
              request.Message,
              plan.AiMessage,
              cancellationToken);

          if (extractionResult.IsSuccess && extractionResult.Value.Facts.Count > 0)
          {
              foreach (var candidate in extractionResult.Value.Facts)
              {
                  var factResult = UserFact.Create(request.UserId, candidate.FactText, candidate.Category);
                  if (factResult.IsSuccess)
                  {
                      await userFactRepository.AddAsync(factResult.Value, cancellationToken);
                  }
              }
              await unitOfWork.SaveChangesAsync(cancellationToken);
          }
      }
      catch (Exception ex)
      {
          logger.LogWarning(ex, "Fact extraction failed - non-critical, continuing");
      }
      ```
    - The fact extraction happens AFTER the main response is built, so extraction failures don't affect the user's chat experience
    - Return the ChatResponse as before (facts are persisted but not returned in the response)

    **4. Register services in Program.cs**:
    - Add `IFactExtractionService` registration in the Gemini provider block:
      ```csharp
      builder.Services.AddHttpClient<IFactExtractionService, GeminiFactExtractionService>();
      ```
    - For Ollama block: Also register `GeminiFactExtractionService` (fact extraction is always Gemini, even when Ollama is the main provider — Ollama's JSON output is too unreliable for structured extraction). But only if Gemini settings are configured. For now, register a no-op or same Gemini service.
    - Actually, simpler approach: Always register GeminiFactExtractionService regardless of AiProvider. Add the registration AFTER the if/else block:
      ```csharp
      // Fact extraction always uses Gemini (structured output reliability)
      builder.Services.Configure<GeminiSettings>(
          builder.Configuration.GetSection(GeminiSettings.SectionName));
      builder.Services.AddHttpClient<IFactExtractionService, GeminiFactExtractionService>();
      ```
    - NOTE: When AiProvider is Ollama, GeminiSettings must still be configured for fact extraction to work. If not configured, the service will fail gracefully (caught by the try-catch in the handler). Move the `Configure<GeminiSettings>` call BEFORE the if/else block so it's always registered:
      ```csharp
      // Always configure Gemini settings (used for fact extraction even with Ollama)
      builder.Services.Configure<GeminiSettings>(
          builder.Configuration.GetSection(GeminiSettings.SectionName));
      ```
      Then in the Gemini if-block, remove the duplicate `Configure<GeminiSettings>` call.

    **5. Verify all builds pass**: `dotnet build` from solution root.
  </action>
  <verify>
    Run `dotnet build` from solution root — all projects must compile.
    Verify SystemPromptBuilder accepts userFacts parameter.
    Verify ProcessUserChatCommandHandler has IFactExtractionService and IGenericRepository<UserFact> injected.
    Verify Program.cs registers IFactExtractionService.
    Verify IAiIntentService interface updated with userFacts parameter.
    Verify both GeminiIntentService and OllamaIntentService updated to accept and pass userFacts.
  </verify>
  <done>
    SystemPromptBuilder includes "What You Know About This User" section with facts.
    Chat handler loads user facts and passes them to AI for personalized responses (ULRN-02).
    Chat handler extracts facts after action execution and persists them (ULRN-01).
    Fact extraction failure is non-critical — caught and logged, doesn't affect chat response.
    IFactExtractionService registered in DI container for both Gemini and Ollama providers.
    All projects compile successfully.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes for all projects (no compilation errors)
2. EF Core migration exists for UserFacts table
3. SystemPromptBuilder.BuildSystemPrompt accepts 3 parameters (habits, tags, facts)
4. ProcessUserChatCommandHandler loads facts, passes to AI, extracts after execution
5. GeminiFactExtractionService has extraction prompt with structured output
6. UserFact.Create validates text length, emptiness, and prompt injection patterns
7. Global query filter on UserFact excludes soft-deleted records
</verification>

<success_criteria>
- UserFact entity persisted to database via EF Core with migration
- Facts extracted from chat conversations via Gemini dual-pass
- Facts loaded into system prompt for subsequent conversations
- Fact extraction failures don't break the chat response
- All projects compile with `dotnet build`
</success_criteria>

<output>
After completion, create `.planning/phases/05-user-learning-system/05-01-SUMMARY.md`
</output>
