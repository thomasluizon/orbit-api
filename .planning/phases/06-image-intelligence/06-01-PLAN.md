---
phase: 06-image-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Orbit.Domain/Interfaces/IAiIntentService.cs
  - src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
  - src/Orbit.Infrastructure/Services/GeminiIntentService.cs
  - src/Orbit.Infrastructure/Services/ImageValidationService.cs
  - src/Orbit.Api/Controllers/ChatController.cs
  - src/Orbit.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "Chat endpoint accepts multipart/form-data with JSON message and optional image file"
    - "Uploaded images are validated for type (magic bytes), size (<20MB), and allowed formats (JPEG, PNG, WebP)"
    - "Validated image bytes are converted to base64 and sent to Gemini Vision API as inline_data"
    - "Text-only chat requests continue to work exactly as before (backward compatible)"
  artifacts:
    - path: "src/Orbit.Infrastructure/Services/ImageValidationService.cs"
      provides: "IImageValidationService interface and implementation with magic byte validation"
      contains: "ImageValidationService"
    - path: "src/Orbit.Api/Controllers/ChatController.cs"
      provides: "Multipart form-data binding with optional IFormFile"
      contains: "IFormFile"
    - path: "src/Orbit.Infrastructure/Services/GeminiIntentService.cs"
      provides: "Gemini Vision inline_data support in request DTOs"
      contains: "InlineData"
    - path: "src/Orbit.Domain/Interfaces/IAiIntentService.cs"
      provides: "Updated interface with optional image parameters"
      contains: "imageData"
  key_links:
    - from: "src/Orbit.Api/Controllers/ChatController.cs"
      to: "src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs"
      via: "ProcessUserChatCommand with ImageData and ImageMimeType"
      pattern: "ProcessUserChatCommand.*ImageData"
    - from: "src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs"
      to: "src/Orbit.Domain/Interfaces/IAiIntentService.cs"
      via: "InterpretAsync with imageData parameter"
      pattern: "InterpretAsync.*imageData"
    - from: "src/Orbit.Infrastructure/Services/GeminiIntentService.cs"
      to: "Gemini Vision API"
      via: "GeminiPart with InlineData containing base64 image"
      pattern: "InlineData.*MimeType.*Data"
---

<objective>
Add image upload support to the chat endpoint with secure file validation and Gemini Vision API integration.

Purpose: Enable users to upload images (photos of schedules, bills, todo lists) alongside chat messages for AI-powered analysis. This is the infrastructure layer -- accepting uploads, validating files securely, converting to base64, and sending to Gemini Vision.

Output: Chat endpoint accepts multipart/form-data, validates image files via magic bytes, passes image data through CQRS pipeline to Gemini Vision API with inline_data.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-image-intelligence/06-RESEARCH.md
@src/Orbit.Domain/Interfaces/IAiIntentService.cs
@src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
@src/Orbit.Infrastructure/Services/GeminiIntentService.cs
@src/Orbit.Api/Controllers/ChatController.cs
@src/Orbit.Api/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image validation service and IAiIntentService interface update</name>
  <files>
    src/Orbit.Infrastructure/Services/ImageValidationService.cs
    src/Orbit.Domain/Interfaces/IAiIntentService.cs
    src/Orbit.Domain/Interfaces/IImageValidationService.cs
    src/Orbit.Api/Program.cs
    src/Orbit.Infrastructure/Orbit.Infrastructure.csproj
  </files>
  <action>
    1. Install FileSignatures NuGet package in Infrastructure project:
       `dotnet add src/Orbit.Infrastructure/Orbit.Infrastructure.csproj package FileSignatures`

    2. Create `src/Orbit.Domain/Interfaces/IImageValidationService.cs`:
       ```csharp
       public interface IImageValidationService
       {
           Task<Result<(string MimeType, long Size)>> ValidateAsync(IFormFile file);
       }
       ```
       NOTE: This interface lives in Domain but references `IFormFile` from `Microsoft.AspNetCore.Http.Features`. This is a pragmatic tradeoff similar to the existing `Microsoft.EntityFrameworkCore` reference in Application. Import via `Microsoft.AspNetCore.Http` namespace.

    3. Create `src/Orbit.Infrastructure/Services/ImageValidationService.cs`:
       - MaxFileSizeBytes = 20_971_520 (20MB, Gemini inline limit)
       - AllowedExtensions = [".jpg", ".jpeg", ".png", ".webp"]
       - Use FileSignatures library's `FileFormatInspector` to validate magic bytes
       - Validation order: size check -> extension check -> magic byte signature check
       - Return `Result<(string MimeType, long Size)>` using existing Result pattern
       - See research file Pattern 4 and Example 2 for implementation reference

    4. Update `src/Orbit.Domain/Interfaces/IAiIntentService.cs`:
       Add optional `byte[]? imageData = null` and `string? imageMimeType = null` parameters to InterpretAsync, BEFORE the cancellationToken parameter:
       ```csharp
       Task<Result<AiActionPlan>> InterpretAsync(
           string userMessage,
           IReadOnlyList<Habit> activeHabits,
           IReadOnlyList<Tag> userTags,
           IReadOnlyList<UserFact> userFacts,
           byte[]? imageData = null,
           string? imageMimeType = null,
           CancellationToken cancellationToken = default);
       ```

    5. Register `IImageValidationService` as singleton in `src/Orbit.Api/Program.cs`:
       `builder.Services.AddSingleton<IImageValidationService, ImageValidationService>();`
       Place after the password/token services section.
  </action>
  <verify>
    Run `dotnet build src/Orbit.Infrastructure/Orbit.Infrastructure.csproj` -- should compile with FileSignatures package.
    Run `dotnet build` at solution level -- should compile (GeminiIntentService will need updating in Task 2, so it may have a build error until then -- if so, that's expected and Task 2 resolves it).
  </verify>
  <done>
    IImageValidationService interface exists in Domain with ValidateAsync method.
    ImageValidationService exists in Infrastructure with magic byte validation using FileSignatures.
    IAiIntentService.InterpretAsync has optional imageData and imageMimeType parameters.
    FileSignatures NuGet package is installed in Infrastructure project.
    IImageValidationService registered in DI container.
  </done>
</task>

<task type="auto">
  <name>Task 2: Gemini Vision support, chat command, and controller multipart binding</name>
  <files>
    src/Orbit.Infrastructure/Services/GeminiIntentService.cs
    src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
    src/Orbit.Api/Controllers/ChatController.cs
  </files>
  <action>
    1. Update `src/Orbit.Infrastructure/Services/GeminiIntentService.cs`:

       a. Update the `GeminiPart` record to support both text and inline_data:
          ```csharp
          private record GeminiPart
          {
              [JsonPropertyName("text")]
              public string? Text { get; init; }

              [JsonPropertyName("inline_data")]
              public InlineData? InlineData { get; init; }
          }

          private record InlineData
          {
              [JsonPropertyName("mime_type")]
              public string MimeType { get; init; } = string.Empty;

              [JsonPropertyName("data")]
              public string Data { get; init; } = string.Empty;
          }
          ```
          NOTE: The existing `GeminiPart.Text` property must change from `string` to `string?` since image parts have no text.

       b. Update InterpretAsync signature to match new interface:
          ```csharp
          public async Task<Result<AiActionPlan>> InterpretAsync(
              string userMessage,
              IReadOnlyList<Habit> activeHabits,
              IReadOnlyList<Tag> userTags,
              IReadOnlyList<UserFact> userFacts,
              byte[]? imageData = null,
              string? imageMimeType = null,
              CancellationToken cancellationToken = default)
          ```

       c. Build the Parts array dynamically -- start with text part, then conditionally add image part:
          ```csharp
          var parts = new List<GeminiPart>
          {
              new GeminiPart { Text = $"{systemPrompt}\n\nUser: {userMessage}" }
          };

          if (imageData != null && !string.IsNullOrWhiteSpace(imageMimeType))
          {
              parts.Add(new GeminiPart
              {
                  InlineData = new InlineData
                  {
                      MimeType = imageMimeType,
                      Data = Convert.ToBase64String(imageData)
                  }
              });
          }
          ```
          Then use `Parts = parts.ToArray()` instead of the inline array initializer.

    2. Update `src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs`:

       a. Add optional image parameters to the command record:
          ```csharp
          public record ProcessUserChatCommand(
              Guid UserId,
              string Message,
              byte[]? ImageData = null,
              string? ImageMimeType = null) : IRequest<Result<ChatResponse>>;
          ```

       b. Pass image data through to the AI intent service call:
          ```csharp
          var planResult = await aiIntentService.InterpretAsync(
              request.Message,
              activeHabits,
              userTags,
              userFacts,
              request.ImageData,
              request.ImageMimeType,
              cancellationToken);
          ```

    3. Update `src/Orbit.Api/Controllers/ChatController.cs`:

       a. Replace the [FromBody] ChatRequest approach with multipart/form-data support.
          The simplest approach for backward compatibility: use [FromForm] with separate form fields.

       b. Update the endpoint to accept both text-only JSON and multipart form requests.
          Create two overloads OR use a single endpoint with [FromForm]:

          Recommended approach -- single endpoint with [FromForm] and conditional image handling:
          ```csharp
          [Authorize]
          [ApiController]
          [Route("api/[controller]")]
          public class ChatController(IMediator mediator, IImageValidationService imageValidation) : ControllerBase
          {
              // Multipart form-data: message (string field) + optional image file
              [HttpPost]
              [RequestFormLimits(MultipartBodyLengthLimit = 20_971_520)] // 20MB
              public async Task<IActionResult> ProcessChat(
                  [FromForm] string message,
                  IFormFile? image,
                  CancellationToken cancellationToken)
              {
                  byte[]? imageData = null;
                  string? imageMimeType = null;

                  if (image is not null)
                  {
                      var validationResult = await imageValidation.ValidateAsync(image);
                      if (validationResult.IsFailure)
                          return BadRequest(new { error = validationResult.Error });

                      using var ms = new MemoryStream();
                      await image.CopyToAsync(ms, cancellationToken);
                      imageData = ms.ToArray();
                      imageMimeType = validationResult.Value.MimeType;
                  }

                  var command = new ProcessUserChatCommand(
                      HttpContext.GetUserId(),
                      message,
                      imageData,
                      imageMimeType);

                  var result = await mediator.Send(command, cancellationToken);

                  return result.IsSuccess
                      ? Ok(result.Value)
                      : BadRequest(new { error = result.Error });
              }
          }
          ```

          IMPORTANT: This changes the endpoint from [FromBody] JSON to [FromForm]. Integration tests will need to send form data instead of JSON. This is a breaking change to the chat endpoint contract -- necessary for multipart support.

          The test helper `SendChatMessage` in AiChatIntegrationTests.cs must be updated to send `MultipartFormDataContent` instead of `PostAsJsonAsync`. This will be handled in Plan 06-02.
  </action>
  <verify>
    Run `dotnet build` at solution root -- the entire solution must compile without errors.
    Note: Integration tests may fail at runtime since the chat endpoint now expects [FromForm] instead of [FromBody], but they must COMPILE. Plan 06-02 will update the tests.
  </verify>
  <done>
    GeminiIntentService supports inline_data with InlineData record for Gemini Vision.
    ProcessUserChatCommand accepts optional ImageData and ImageMimeType.
    ChatController accepts multipart/form-data with optional image file.
    Image validation runs before processing -- invalid images return 400.
    Text-only requests work by passing null for image parameters.
    Solution compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes for entire solution
2. GeminiIntentService has InlineData record and builds multipart Gemini request when image provided
3. ChatController accepts [FromForm] with optional IFormFile
4. ImageValidationService validates magic bytes via FileSignatures
5. IAiIntentService interface has imageData/imageMimeType parameters
6. DI container has IImageValidationService registered
</verification>

<success_criteria>
- Image upload infrastructure is complete: validation, conversion, Gemini Vision request building
- Chat endpoint accepts multipart/form-data with backward-compatible text-only support
- File validation rejects non-image files and oversized uploads
- Gemini Vision integration sends inline_data when image is provided
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-image-intelligence/06-01-SUMMARY.md`
</output>
