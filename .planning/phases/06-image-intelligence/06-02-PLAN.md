---
phase: 06-image-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
  - tests/Orbit.IntegrationTests/AiChatIntegrationTests.cs
autonomous: true

must_haves:
  truths:
    - "AI system prompt includes image analysis instructions when image is uploaded"
    - "AI uses SuggestBreakdown for image-based habit suggestions, never auto-creates"
    - "Existing text-only chat integration tests pass with updated multipart form-data format"
    - "Image upload integration test sends an image and receives SuggestBreakdown suggestions"
  artifacts:
    - path: "src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs"
      provides: "Image analysis instructions in system prompt"
      contains: "Image Analysis Instructions"
    - path: "tests/Orbit.IntegrationTests/AiChatIntegrationTests.cs"
      provides: "Updated tests using MultipartFormDataContent and new image upload test"
      contains: "MultipartFormDataContent"
  key_links:
    - from: "src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs"
      to: "src/Orbit.Infrastructure/Services/GeminiIntentService.cs"
      via: "BuildSystemPrompt with hasImage parameter controls prompt content"
      pattern: "BuildSystemPrompt.*hasImage"
    - from: "tests/Orbit.IntegrationTests/AiChatIntegrationTests.cs"
      to: "src/Orbit.Api/Controllers/ChatController.cs"
      via: "MultipartFormDataContent with 'message' field and optional 'image' file"
      pattern: "MultipartFormDataContent.*message"
---

<objective>
Add image-aware AI prompting and update integration tests for multipart chat endpoint.

Purpose: Complete the image intelligence feature by teaching the AI how to analyze images (extract habits, infer frequencies, require confirmation via SuggestBreakdown) and ensuring the entire pipeline is tested end-to-end -- both existing text-only flows and new image upload flows.

Output: SystemPromptBuilder includes image analysis instructions, all existing tests pass with new multipart format, and a new integration test verifies image-to-suggestion pipeline.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-image-intelligence/06-RESEARCH.md
@.planning/phases/06-image-intelligence/06-01-SUMMARY.md
@src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
@src/Orbit.Infrastructure/Services/GeminiIntentService.cs
@tests/Orbit.IntegrationTests/AiChatIntegrationTests.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image-aware system prompt and GeminiIntentService prompt flag</name>
  <files>
    src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
    src/Orbit.Infrastructure/Services/GeminiIntentService.cs
  </files>
  <action>
    1. Update `SystemPromptBuilder.BuildSystemPrompt` to accept an optional `bool hasImage = false` parameter:
       ```csharp
       public static string BuildSystemPrompt(
           IReadOnlyList<Habit> activeHabits,
           IReadOnlyList<Tag> userTags,
           IReadOnlyList<UserFact> userFacts,
           bool hasImage = false)
       ```

    2. When `hasImage` is true, append image analysis instructions BEFORE the "Response JSON Schema & Examples" section. Add after the "Today's Date" section:
       ```
       ## Image Analysis Instructions
       When the user uploads an image (photo of schedule, bill, to-do list, calendar):
       1. Extract all habit-like items (tasks, recurring events, goals, responsibilities)
       2. Infer frequency from visual cues:
          - Daily checkboxes or daily columns -> FrequencyUnit: Day, FrequencyQuantity: 1
          - Week columns (Mon-Sun) or weekly markers -> FrequencyUnit: Week, FrequencyQuantity: 1
          - Month labels or monthly markers -> FrequencyUnit: Month, FrequencyQuantity: 1
          - Specific days listed -> Use Days array (Monday, Tuesday, etc.)
       3. Extract due dates from dates visible in image (format: YYYY-MM-DD)
       4. Extract amounts for financial habits (bill amount, subscription cost) and include in description
       5. CRITICAL: For image-based habit extraction, ALWAYS use SuggestBreakdown action type
          - NEVER create habits directly from image analysis
          - User must explicitly confirm which suggestions to create
       6. Include extracted text/context in habit descriptions for clarity
       7. If the image contains no habit-relevant information, return empty actions with an aiMessage explaining what you see

       Example image analysis response:
       {
         "aiMessage": "I found 3 recurring tasks in your schedule image.",
         "actions": [
           {
             "type": "SuggestBreakdown",
             "title": "Schedule from Image",
             "frequencyUnit": "Day",
             "frequencyQuantity": 1,
             "dueDate": "YYYY-MM-DD",
             "suggestedSubHabits": [
               { "type": "CreateHabit", "title": "Morning jog", "frequencyUnit": "Week", "frequencyQuantity": 3, "days": ["Monday", "Wednesday", "Friday"], "dueDate": "YYYY-MM-DD" },
               { "type": "CreateHabit", "title": "Team meeting", "frequencyUnit": "Week", "frequencyQuantity": 1, "days": ["Tuesday"], "dueDate": "YYYY-MM-DD" }
             ]
           }
         ]
       }
       ```
       Use raw string literal with `$$"""..."""` for sections containing JSON braces.

    3. Update GeminiIntentService.InterpretAsync to pass `hasImage: imageData != null` to BuildSystemPrompt:
       ```csharp
       var systemPrompt = SystemPromptBuilder.BuildSystemPrompt(
           activeHabits, userTags, userFacts,
           hasImage: imageData != null);
       ```
  </action>
  <verify>
    Run `dotnet build` -- solution must compile.
    Visually inspect that BuildSystemPrompt with `hasImage: true` includes the image analysis section and with `hasImage: false` does not.
  </verify>
  <done>
    SystemPromptBuilder conditionally includes image analysis instructions when hasImage is true.
    GeminiIntentService passes hasImage flag based on presence of imageData.
    Image analysis instructions mandate SuggestBreakdown (never auto-create).
    Text-only requests get the same prompt as before (no image instructions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update integration tests for multipart format and add image upload test</name>
  <files>
    tests/Orbit.IntegrationTests/AiChatIntegrationTests.cs
    tests/Orbit.IntegrationTests/TestData/sample-schedule.png
  </files>
  <action>
    1. Update the `SendChatMessage` helper method in `AiChatIntegrationTests.cs` to send `MultipartFormDataContent` instead of `PostAsJsonAsync`:
       ```csharp
       private async Task<ChatResponse> SendChatMessage(string message)
       {
           await RateLimitSemaphore.WaitAsync();
           try
           {
               var timeSinceLastCall = DateTime.UtcNow - LastApiCall;
               var minDelay = TimeSpan.FromSeconds(10);

               if (timeSinceLastCall < minDelay)
               {
                   var remainingDelay = minDelay - timeSinceLastCall;
                   Console.WriteLine($"Rate limiting: Waiting {remainingDelay.TotalSeconds:F1}s before next API call...");
                   await Task.Delay(remainingDelay);
               }

               using var content = new MultipartFormDataContent();
               content.Add(new StringContent(message), "message");

               var httpResponse = await _client.PostAsync("/api/chat", content);
               LastApiCall = DateTime.UtcNow;

               if (!httpResponse.IsSuccessStatusCode)
               {
                   var errorContent = await httpResponse.Content.ReadAsStringAsync();
                   Console.WriteLine($"API ERROR ({httpResponse.StatusCode}): {errorContent}");
                   Console.WriteLine($"   For message: '{message}'");
               }

               httpResponse.StatusCode.Should().Be(HttpStatusCode.OK);

               var responseText = await httpResponse.Content.ReadAsStringAsync();
               var response = JsonSerializer.Deserialize<ChatResponse>(responseText, new JsonSerializerOptions
               {
                   PropertyNameCaseInsensitive = true
               });

               response.Should().NotBeNull();
               return response!;
           }
           finally
           {
               RateLimitSemaphore.Release();
           }
       }
       ```

    2. Also update the `Chat_EmptyMessage_ShouldHandleGracefully` test -- it currently sends JSON directly:
       ```csharp
       [Fact]
       public async Task Chat_EmptyMessage_ShouldHandleGracefully()
       {
           using var content = new MultipartFormDataContent();
           content.Add(new StringContent(""), "message");
           var httpResponse = await _client.PostAsync("/api/chat", content);
           httpResponse.StatusCode.Should().BeOneOf(HttpStatusCode.OK, HttpStatusCode.BadRequest);
       }
       ```

    3. Create a minimal test PNG image file programmatically for the image upload test.
       Create a helper method that generates a valid 1x1 pixel PNG in memory (PNG has a well-known format: 8-byte signature + IHDR + IDAT + IEND chunks). This avoids needing a physical test image file on disk.

       ```csharp
       private static byte[] CreateMinimalPng()
       {
           // Minimal valid 1x1 white pixel PNG
           // PNG signature + IHDR + IDAT + IEND
           return new byte[]
           {
               0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
               0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR chunk length + type
               0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 pixels
               0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53, // 8-bit RGB, CRC
               0xDE, 0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41, // IDAT chunk
               0x54, 0x08, 0xD7, 0x63, 0xF8, 0xCF, 0xC0, 0x00, // compressed data
               0x00, 0x00, 0x02, 0x00, 0x01, 0xE2, 0x21, 0xBC, // CRC
               0x33, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, // IEND chunk
               0x44, 0xAE, 0x42, 0x60, 0x82                     // IEND CRC
           };
       }
       ```

    4. Add a new integration test for image upload with chat message:
       ```csharp
       [Fact]
       public async Task Chat_UploadImageWithMessage_ShouldReturnSuggestions()
       {
           await RateLimitSemaphore.WaitAsync();
           try
           {
               var timeSinceLastCall = DateTime.UtcNow - LastApiCall;
               var minDelay = TimeSpan.FromSeconds(10);
               if (timeSinceLastCall < minDelay)
                   await Task.Delay(minDelay - timeSinceLastCall);

               var imageBytes = CreateMinimalPng();
               using var content = new MultipartFormDataContent();
               content.Add(new StringContent("Create habits from this schedule image"), "message");

               var imageContent = new ByteArrayContent(imageBytes);
               imageContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("image/png");
               content.Add(imageContent, "image", "schedule.png");

               var httpResponse = await _client.PostAsync("/api/chat", content);
               LastApiCall = DateTime.UtcNow;

               httpResponse.StatusCode.Should().Be(HttpStatusCode.OK);

               var responseText = await httpResponse.Content.ReadAsStringAsync();
               var response = JsonSerializer.Deserialize<ChatResponse>(responseText, new JsonSerializerOptions
               {
                   PropertyNameCaseInsensitive = true
               });

               response.Should().NotBeNull();
               response!.AiMessage.Should().NotBeNullOrEmpty();
               // The AI should respond to the image -- it may return SuggestBreakdown or empty actions
               // depending on what Gemini Vision interprets from the minimal 1x1 PNG.
               // The key verification is that the request succeeded (200 OK) and the pipeline works end-to-end.
           }
           finally
           {
               RateLimitSemaphore.Release();
           }
       }
       ```

    5. Add a test for invalid file upload rejection:
       ```csharp
       [Fact]
       public async Task Chat_UploadInvalidFile_ShouldReturn400()
       {
           // Arrange - Create a fake text file disguised as image
           var fakeImageBytes = System.Text.Encoding.UTF8.GetBytes("This is not an image");
           using var content = new MultipartFormDataContent();
           content.Add(new StringContent("Analyze this"), "message");

           var imageContent = new ByteArrayContent(fakeImageBytes);
           imageContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("image/png");
           content.Add(imageContent, "image", "fake.png");

           // Act
           var httpResponse = await _client.PostAsync("/api/chat", content);

           // Assert - Should reject with 400 due to invalid file signature
           httpResponse.StatusCode.Should().Be(HttpStatusCode.BadRequest);
       }
       ```
  </action>
  <verify>
    Run `dotnet build` -- solution must compile.
    Run `dotnet test tests/Orbit.IntegrationTests/ --filter "Chat_UploadInvalidFile_ShouldReturn400"` -- should pass (validates file rejection).
    Run `dotnet test tests/Orbit.IntegrationTests/ --filter "Chat_CreateBooleanHabit_ShouldSucceed"` -- should pass (validates backward compatibility with multipart format).
    Run `dotnet test tests/Orbit.IntegrationTests/ --filter "Chat_UploadImageWithMessage_ShouldReturnSuggestions"` -- should pass (validates end-to-end image pipeline with Gemini Vision).
  </verify>
  <done>
    SystemPromptBuilder includes image analysis instructions when hasImage is true.
    All existing 14 chat integration tests pass with multipart form-data format.
    New test verifies image upload succeeds and returns AI response.
    New test verifies invalid file upload returns 400.
    Full end-to-end pipeline works: upload -> validate -> base64 -> Gemini Vision -> SuggestBreakdown.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` passes for entire solution
2. `dotnet test tests/Orbit.IntegrationTests/ --filter "AiChatIntegrationTests"` -- all tests pass (existing + new)
3. SystemPromptBuilder conditionally includes image analysis instructions
4. Image upload integration test receives 200 OK and valid response
5. Invalid file upload test receives 400 Bad Request
6. Text-only chat requests continue working with multipart form format
</verification>

<success_criteria>
- AI system prompt instructs Gemini to use SuggestBreakdown for image-based suggestions (IMGP-04)
- All existing text-only tests pass with updated multipart format (backward compatibility)
- Image upload test proves end-to-end pipeline works (IMGP-01, IMGP-02, IMGP-03)
- Invalid file upload is properly rejected (security)
- Phase 6 success criteria fully met: upload -> validate -> analyze -> suggest -> confirm
</success_criteria>

<output>
After completion, create `.planning/phases/06-image-intelligence/06-02-SUMMARY.md`
</output>
