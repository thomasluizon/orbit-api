---
phase: 02-habit-domain-extensions
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/Orbit.Application/Tags/Commands/CreateTagCommand.cs
  - src/Orbit.Application/Tags/Commands/DeleteTagCommand.cs
  - src/Orbit.Application/Tags/Commands/AssignTagCommand.cs
  - src/Orbit.Application/Tags/Commands/UnassignTagCommand.cs
  - src/Orbit.Application/Tags/Queries/GetTagsQuery.cs
  - src/Orbit.Application/Tags/Validators/CreateTagCommandValidator.cs
  - src/Orbit.Application/Tags/Validators/AssignTagCommandValidator.cs
  - src/Orbit.Application/Profile/Commands/SetTimezoneCommand.cs
  - src/Orbit.Application/Profile/Queries/GetProfileQuery.cs
  - src/Orbit.Application/Profile/Validators/SetTimezoneCommandValidator.cs
  - src/Orbit.Api/Controllers/TagsController.cs
  - src/Orbit.Api/Controllers/ProfileController.cs
autonomous: true

must_haves:
  truths:
    - "User can create a tag with name and hex color via API"
    - "User can delete their own tag via API"
    - "User can assign a tag to a habit via API"
    - "User can remove a tag from a habit via API"
    - "User can list their tags via API"
    - "User can filter habits by tag IDs via query parameter"
    - "User can set their timezone via API"
    - "User can view their profile (name, email, timezone) via API"
    - "Tag names are unique per user (duplicate returns error)"
  artifacts:
    - path: "src/Orbit.Application/Tags/Commands/CreateTagCommand.cs"
      provides: "Tag creation with name uniqueness check"
    - path: "src/Orbit.Application/Tags/Commands/AssignTagCommand.cs"
      provides: "Assign tag to habit via HabitTag join"
    - path: "src/Orbit.Application/Tags/Commands/UnassignTagCommand.cs"
      provides: "Remove tag from habit"
    - path: "src/Orbit.Application/Tags/Queries/GetTagsQuery.cs"
      provides: "List user's tags"
    - path: "src/Orbit.Api/Controllers/TagsController.cs"
      provides: "Full CRUD + assign/unassign REST endpoints for tags"
    - path: "src/Orbit.Application/Profile/Commands/SetTimezoneCommand.cs"
      provides: "Timezone setting with IANA validation"
    - path: "src/Orbit.Api/Controllers/ProfileController.cs"
      provides: "Profile GET and timezone PUT endpoints"
  key_links:
    - from: "src/Orbit.Api/Controllers/TagsController.cs"
      to: "src/Orbit.Application/Tags/Commands/CreateTagCommand.cs"
      via: "POST /api/tags -> mediator.Send(CreateTagCommand)"
      pattern: "CreateTagCommand"
    - from: "src/Orbit.Api/Controllers/TagsController.cs"
      to: "src/Orbit.Application/Tags/Commands/AssignTagCommand.cs"
      via: "POST /api/habits/{id}/tags/{tagId} -> mediator.Send(AssignTagCommand)"
      pattern: "AssignTagCommand"
    - from: "src/Orbit.Api/Controllers/ProfileController.cs"
      to: "src/Orbit.Application/Profile/Commands/SetTimezoneCommand.cs"
      via: "PUT /api/profile/timezone -> mediator.Send(SetTimezoneCommand)"
      pattern: "SetTimezoneCommand"
    - from: "src/Orbit.Application/Tags/Commands/CreateTagCommand.cs"
      to: "src/Orbit.Domain/Entities/Tag.cs"
      via: "Tag.Create factory method"
      pattern: "Tag.Create"
    - from: "src/Orbit.Application/Profile/Commands/SetTimezoneCommand.cs"
      to: "src/Orbit.Domain/Entities/User.cs"
      via: "user.SetTimeZone() domain method"
      pattern: "SetTimeZone"
---

<objective>
Implement tags feature (CRUD, assignment, filtering) and user profile/timezone feature as complete vertical slices with commands, queries, validators, and controllers.

Purpose: Delivers requirements TAG-01, TAG-02, TAG-03 (tags with colors, assign to habits, filter by tags) and PROF-01 (user timezone). These are independent from the habit extensions in Plan 02.
Output: 2 new controllers (TagsController, ProfileController), 6 new command files, 2 new query files, 3 new validator files.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-habit-domain-extensions/02-RESEARCH.md
@.planning/phases/02-habit-domain-extensions/02-01-SUMMARY.md
@src/Orbit.Api/Controllers/HabitsController.cs
@src/Orbit.Api/Program.cs
@src/Orbit.Domain/Entities/Tag.cs
@src/Orbit.Domain/Entities/HabitTag.cs
@src/Orbit.Domain/Entities/User.cs
@src/Orbit.Infrastructure/Persistence/OrbitDbContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tags feature -- commands, queries, validators, and controller</name>
  <files>
    src/Orbit.Application/Tags/Commands/CreateTagCommand.cs
    src/Orbit.Application/Tags/Commands/DeleteTagCommand.cs
    src/Orbit.Application/Tags/Commands/AssignTagCommand.cs
    src/Orbit.Application/Tags/Commands/UnassignTagCommand.cs
    src/Orbit.Application/Tags/Queries/GetTagsQuery.cs
    src/Orbit.Application/Tags/Validators/CreateTagCommandValidator.cs
    src/Orbit.Application/Tags/Validators/AssignTagCommandValidator.cs
    src/Orbit.Api/Controllers/TagsController.cs
  </files>
  <action>
    Create the `Tags` folder structure under `src/Orbit.Application/Tags/` with `Commands/`, `Queries/`, and `Validators/` subfolders.

    **New: CreateTagCommand.cs** -- Record: `CreateTagCommand(Guid UserId, string Name, string Color) : IRequest<Result<Guid>>`.
    Handler: inject `IGenericRepository<Tag>` and `IUnitOfWork`. First check uniqueness: `var existing = await tagRepository.FindAsync(t => t.UserId == request.UserId && t.Name == request.Name.Trim())`. If any exist, return `Result.Failure<Guid>("A tag with this name already exists.")`. Then call `Tag.Create(request.UserId, request.Name, request.Color)`. If failure, propagate. Add and save. Return tag Id.

    **New: DeleteTagCommand.cs** -- Record: `DeleteTagCommand(Guid UserId, Guid TagId) : IRequest<Result>`.
    Handler: inject `IGenericRepository<Tag>` and `IUnitOfWork`. Load tag by ID. Verify exists and ownership (tag.UserId == request.UserId). Remove and save. The cascade delete on HabitTag will automatically clean up assignments.

    **New: AssignTagCommand.cs** -- Record: `AssignTagCommand(Guid UserId, Guid HabitId, Guid TagId) : IRequest<Result>`.
    Handler: inject `OrbitDbContext` directly (need to add HabitTag which is not a regular Entity and can't use GenericRepository since HabitTag does not extend Entity). Load habit and verify ownership. Load tag and verify ownership. Check if assignment already exists: `dbContext.Set<HabitTag>().AnyAsync(ht => ht.HabitId == request.HabitId && ht.TagId == request.TagId)`. If exists, return success (idempotent). Otherwise, add `new HabitTag(request.HabitId, request.TagId)` to `dbContext.Set<HabitTag>()`. Save.

    **New: UnassignTagCommand.cs** -- Record: `UnassignTagCommand(Guid UserId, Guid HabitId, Guid TagId) : IRequest<Result>`.
    Handler: inject `OrbitDbContext`. Load habit and verify ownership. Find HabitTag: `dbContext.Set<HabitTag>().FirstOrDefaultAsync(ht => ht.HabitId == request.HabitId && ht.TagId == request.TagId)`. If not found, return success (idempotent). Remove and save.

    **New: GetTagsQuery.cs** -- Record: `GetTagsQuery(Guid UserId) : IRequest<IReadOnlyList<Tag>>`.
    Handler: inject `IGenericRepository<Tag>`. Return `await tagRepository.FindAsync(t => t.UserId == request.UserId, cancellationToken)`.

    **New: CreateTagCommandValidator.cs** -- Validate: UserId NotEmpty, Name NotEmpty + MaximumLength(50), Color NotEmpty + must match regex `^#[0-9A-Fa-f]{6}$` with `.Matches()`.

    **New: AssignTagCommandValidator.cs** -- Validate: UserId NotEmpty, HabitId NotEmpty, TagId NotEmpty.

    **New: TagsController.cs** -- `[Authorize] [ApiController] [Route("api/[controller]")]`. Inject `IMediator`. Define request records inline:
    - `record CreateTagRequest(string Name, string Color)`

    Endpoints:
    - `GET /api/tags` -> GetTagsQuery -> Ok(tags)
    - `POST /api/tags` -> CreateTagCommand -> CreatedAtAction with tag Id
    - `DELETE /api/tags/{id}` -> DeleteTagCommand -> NoContent or BadRequest

    Also add tag assignment endpoints (these live on TagsController for REST clarity but reference habits):
    - `POST /api/habits/{habitId}/tags/{tagId}` -- BUT wait, this route would conflict with HabitsController since it starts with `/api/habits/`. Instead, put these on TagsController but with explicit routes:

    REVISED: Put assign/unassign on HabitsController? No -- Plan 02 owns HabitsController. Better: put them on TagsController with full route specification:
    - `[HttpPost("/api/habits/{habitId:guid}/tags/{tagId:guid}")]` -> AssignTagCommand -> Ok
    - `[HttpDelete("/api/habits/{habitId:guid}/tags/{tagId:guid}")]` -> UnassignTagCommand -> NoContent

    Using absolute route paths (`/api/habits/...`) on TagsController overrides the `[Route("api/[controller]")]` attribute for these specific actions. This is standard ASP.NET Core.
  </action>
  <verify>
    Run `dotnet build src/Orbit.Application/Orbit.Application.csproj` and `dotnet build src/Orbit.Api/Orbit.Api.csproj` -- both must compile with zero errors.
    Verify all command, query, and validator files exist under src/Orbit.Application/Tags/.
    Verify TagsController exists with all 5 endpoints.
  </verify>
  <done>
    Tag CRUD complete: create (with name uniqueness check), delete (with cascade), list. Tag assignment: assign to habit (idempotent), unassign from habit (idempotent). All validators enforce constraints. TagsController exposes all 5 endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Profile feature and habit-by-tag filtering</name>
  <files>
    src/Orbit.Application/Profile/Commands/SetTimezoneCommand.cs
    src/Orbit.Application/Profile/Queries/GetProfileQuery.cs
    src/Orbit.Application/Profile/Validators/SetTimezoneCommandValidator.cs
    src/Orbit.Api/Controllers/ProfileController.cs
  </files>
  <action>
    Create the `Profile` folder structure under `src/Orbit.Application/Profile/` with `Commands/`, `Queries/`, and `Validators/` subfolders.

    **New: SetTimezoneCommand.cs** -- Record: `SetTimezoneCommand(Guid UserId, string TimeZone) : IRequest<Result>`.
    Handler: inject `IGenericRepository<User>` and `IUnitOfWork`. Load user via GetByIdAsync (tracked). Verify exists. Call `user.SetTimeZone(request.TimeZone)` (the domain method validates via TimeZoneInfo.FindSystemTimeZoneById). If failure, propagate. Save. Return success.

    NOTE: GenericRepository.GetByIdAsync uses `FindAsync` which returns tracked entities (it uses `_dbSet.FindAsync`, not AsNoTracking). So this works for writes.

    **New: GetProfileQuery.cs** -- Record: `GetProfileQuery(Guid UserId) : IRequest<ProfileResponse>` where `ProfileResponse` is a nested record: `record ProfileResponse(string Name, string Email, string? TimeZone)`.
    Handler: inject `IGenericRepository<User>`. Load user via GetByIdAsync. Return new ProfileResponse(user.Name, user.Email, user.TimeZone).

    **New: SetTimezoneCommandValidator.cs** -- Validate: UserId NotEmpty, TimeZone NotEmpty + MaximumLength(100).
    NOTE: The actual IANA timezone validation happens in the domain method (User.SetTimeZone), not the validator. The validator just ensures the string is present and reasonable length. This follows the existing pattern where FluentValidation handles structural validation and domain methods handle business validation.

    **New: ProfileController.cs** -- `[Authorize] [ApiController] [Route("api/[controller]")]`. Inject `IMediator`. Define request record:
    - `record SetTimezoneRequest(string TimeZone)`

    Endpoints:
    - `GET /api/profile` -> GetProfileQuery -> Ok(profile)
    - `PUT /api/profile/timezone` -> SetTimezoneCommand -> Ok or BadRequest

    ```csharp
    [HttpGet]
    public async Task<IActionResult> GetProfile(CancellationToken ct)
    {
        var query = new GetProfileQuery(HttpContext.GetUserId());
        var profile = await mediator.Send(query, ct);
        return Ok(profile);
    }

    [HttpPut("timezone")]
    public async Task<IActionResult> SetTimezone([FromBody] SetTimezoneRequest request, CancellationToken ct)
    {
        var command = new SetTimezoneCommand(HttpContext.GetUserId(), request.TimeZone);
        var result = await mediator.Send(command, ct);
        return result.IsSuccess ? Ok() : BadRequest(new { error = result.Error });
    }
    ```

    NOTE on habit-by-tag filtering: The GetHabitsQuery in Plan 02 already uses FindAsync with includes for SubHabits and Tags. To add tag filtering, Plan 02 would need to modify GetHabitsQuery. However, tag filtering requires a slightly different approach -- it needs to filter WHERE habits have specific tags, which is better done with a direct DbContext query rather than the generic repository.

    APPROACH: Add an optional `IReadOnlyList<Guid>? TagIds` parameter to GetHabitsQuery (Plan 02 owns that file). BUT we can't modify it here since Plan 02 owns it. SOLUTION: Since Plan 02 and 03 are Wave 2 (parallel), and GetHabitsQuery is in Plan 02's file list, we need to handle tag filtering there. HOWEVER, the simplest approach that avoids file conflicts: create a separate query specifically for filtered habits.

    REVISED: Do NOT modify GetHabitsQuery here. Instead, add a `FilterHabitsByTagsQuery` as an ALTERNATIVE query endpoint that Plan 02 does not touch. BUT this creates a confusing API. BETTER: accept that tag filtering is a minor addition to GetHabitsQuery. Since Plan 02 already modifies GetHabitsQuery to add includes, we should note in Plan 02 that tag filtering via query parameter should also be added there.

    FINAL DECISION: Tag filtering is best handled as a query parameter on GET /api/habits. Plan 02 already owns GetHabitsQuery.cs and HabitsController.cs. Add a note in this plan that tag filtering support (TAG-03 partial) requires a small addition to Plan 02's GetHabitsQuery. The executor of Plan 02 should add `IReadOnlyList<Guid>? TagIds = null` to GetHabitsQuery and filter in the handler:
    ```csharp
    // In GetHabitsQueryHandler, after the base query
    if (request.TagIds is { Count: > 0 })
    {
        // Filter using DbContext directly since GenericRepository doesn't support complex LINQ
        // OR use the includes overload with a custom filter
    }
    ```

    ACTUALLY, to keep plans truly independent and avoid cross-plan coordination, implement tag filtering HERE on a separate endpoint on TagsController:
    - `GET /api/tags/{tagId}/habits` -> returns habits that have the specified tag

    No -- that's an awkward API. The cleanest solution: since both Plan 02 and 03 are Wave 2, and the user might run them sequentially, let Plan 02 handle the GetHabitsQuery modification (it already includes tags). Plan 02 should add optional TagIds filtering to GetHabitsQuery. Document this dependency.

    SIMPLEST VALID APPROACH for this plan: Add `[HttpGet("/api/habits")] [QueryParameter]` tag filter endpoint on TagsController? No, route conflict.

    FINAL: Leave habit-by-tag filtering as a documented note. Plan 02 owns GetHabitsQuery and HabitsController. Plan 02's Task 1 already modifies GetHabitsQuery to include tags. Add `IReadOnlyList<Guid>? TagIds = null` to GetHabitsQuery record and add filtering logic in the handler + a `[FromQuery] string? tags` parameter on HabitsController.GetHabits. This is a small addition that naturally fits in Plan 02 since it's modifying those exact files anyway. Document this in Plan 02's action section -- actually Plan 02 is already written. We'll handle this via a note to the executor.

    ADD TO THIS PLAN: Create a small shim -- update GetHabitsQuery to accept TagIds and filter. BUT GetHabitsQuery.cs is in Plan 02's files_modified list. Running them in parallel would cause conflicts.

    RESOLUTION: These plans run as Wave 2 but sequentially in practice (Claude executor runs one plan at a time). Plan 02 runs first (listed first), Plan 03 runs second. So Plan 03 CAN safely modify GetHabitsQuery after Plan 02 has finished. Add GetHabitsQuery.cs and HabitsController.cs to this plan's scope for the tag filtering addition only.

    ADD: After Profile feature is complete, add tag filtering to the existing GetHabitsQuery:
    - Modify GetHabitsQuery record to add: `IReadOnlyList<Guid>? TagIds = null`
    - Modify GetHabitsQueryHandler to add tag filter after the base query (check if TagIds has items, then filter with `.Where(h => h.Tags.Any(t => request.TagIds.Contains(t.Id)))` -- but this can't be done with the generic repository includes overload easily.

    BETTER: For tag filtering, modify the handler to use `OrbitDbContext` directly when TagIds are provided, since the generic repository can't express this LINQ. OR, use the includes overload and filter in-memory (fine for small result sets). OR, add the filter to the predicate expression -- but `Tags` won't be populated on the expression level with AsNoTracking...

    CLEANEST: Modify GetHabitsQueryHandler to inject BOTH `IGenericRepository<Habit>` and `OrbitDbContext`. When TagIds is null, use existing repository call. When TagIds is provided, use DbContext directly:
    ```csharp
    if (request.TagIds is { Count: > 0 })
    {
        return await dbContext.Habits
            .AsNoTracking()
            .Include(h => h.SubHabits.Where(sh => sh.IsActive).OrderBy(sh => sh.SortOrder))
            .Include(h => h.Tags)
            .Where(h => h.UserId == request.UserId && h.IsActive)
            .Where(h => h.Tags.Any(t => request.TagIds.Contains(t.Id)))
            .ToListAsync(cancellationToken);
    }
    ```

    Add to HabitsController.GetHabits: accept `[FromQuery] string? tags` parameter. Parse comma-separated GUIDs: `var tagIds = tags?.Split(',').Select(Guid.Parse).ToList()`. Pass to GetHabitsQuery.

    Include these files in this task:
    - src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs (add TagIds + handler logic)
    - src/Orbit.Api/Controllers/HabitsController.cs (add tags query param to GetHabits)
  </action>
  <verify>
    Run `dotnet build Orbit.slnx` -- must compile with zero errors.
    Verify ProfileController exists with GET /api/profile and PUT /api/profile/timezone.
    Verify SetTimezoneCommand, GetProfileQuery, and SetTimezoneCommandValidator exist.
    Verify GetHabitsQuery accepts TagIds parameter.
    Verify HabitsController.GetHabits accepts tags query parameter.
  </verify>
  <done>
    Profile feature complete: GET profile (name, email, timezone), PUT timezone (IANA validation). Tag filtering complete: GET /api/habits?tags=id1,id2 filters habits by tag. All new validators enforce constraints.
  </done>
</task>

</tasks>

<verification>
- `dotnet build Orbit.slnx` compiles with zero errors
- GET /api/tags returns user's tags
- POST /api/tags creates a tag (duplicate name returns error)
- DELETE /api/tags/{id} deletes a tag
- POST /api/habits/{id}/tags/{tagId} assigns tag to habit
- DELETE /api/habits/{id}/tags/{tagId} removes tag from habit
- GET /api/habits?tags=id1,id2 filters habits by tags
- GET /api/profile returns name, email, timezone
- PUT /api/profile/timezone sets timezone (invalid IANA ID returns error)
</verification>

<success_criteria>
- TAG-01: Tags with name + color can be created and listed
- TAG-02: Tags can be assigned to and removed from habits
- TAG-03: Habits can be filtered by tag IDs
- PROF-01: User can set IANA timezone, stored on User entity
- All validators enforce input constraints
- 2 new controllers (TagsController, ProfileController) with all endpoints
- Solution builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-habit-domain-extensions/02-03-SUMMARY.md`
</output>
