---
phase: 02-habit-domain-extensions
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/Orbit.Application/Habits/Commands/CreateHabitCommand.cs
  - src/Orbit.Application/Habits/Commands/LogHabitCommand.cs
  - src/Orbit.Application/Habits/Commands/AddSubHabitCommand.cs
  - src/Orbit.Application/Habits/Commands/RemoveSubHabitCommand.cs
  - src/Orbit.Application/Habits/Commands/LogSubHabitCommand.cs
  - src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs
  - src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs
  - src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs
  - src/Orbit.Application/Habits/Validators/AddSubHabitCommandValidator.cs
  - src/Orbit.Application/Habits/Validators/LogSubHabitCommandValidator.cs
  - src/Orbit.Api/Controllers/HabitsController.cs
  - src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
  - src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
  - src/Orbit.Domain/Models/AiAction.cs
autonomous: true

must_haves:
  truths:
    - "User can create a habit with IsNegative flag via API"
    - "User can create a parent habit with initial sub-habits via API"
    - "User can add a sub-habit to an existing habit via API"
    - "User can remove a sub-habit from a habit via API"
    - "User can log individual sub-habit completions via API"
    - "User can add a text note when logging any habit via API"
    - "GetHabits returns habits with their sub-habits and tags included"
    - "Negative boolean habits allow multiple logs per day"
    - "AI prompt knows about IsNegative flag and note field for logging"
  artifacts:
    - path: "src/Orbit.Application/Habits/Commands/AddSubHabitCommand.cs"
      provides: "Command + handler to add sub-habit to existing habit"
    - path: "src/Orbit.Application/Habits/Commands/RemoveSubHabitCommand.cs"
      provides: "Command + handler to deactivate a sub-habit"
    - path: "src/Orbit.Application/Habits/Commands/LogSubHabitCommand.cs"
      provides: "Command + handler to log sub-habit completions for a date"
    - path: "src/Orbit.Api/Controllers/HabitsController.cs"
      provides: "Updated controller with sub-habit endpoints, note in log, isNegative in create"
    - path: "src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs"
      provides: "AI prompt updated with IsNegative and Note fields"
  key_links:
    - from: "src/Orbit.Api/Controllers/HabitsController.cs"
      to: "src/Orbit.Application/Habits/Commands/AddSubHabitCommand.cs"
      via: "POST /api/habits/{id}/sub-habits -> mediator.Send(AddSubHabitCommand)"
      pattern: "AddSubHabitCommand"
    - from: "src/Orbit.Api/Controllers/HabitsController.cs"
      to: "src/Orbit.Application/Habits/Commands/LogSubHabitCommand.cs"
      via: "POST /api/habits/{id}/sub-habits/log -> mediator.Send(LogSubHabitCommand)"
      pattern: "LogSubHabitCommand"
    - from: "src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs"
      to: "src/Orbit.Domain/Interfaces/IGenericRepository.cs"
      via: "FindAsync with includes overload for SubHabits and Tags"
      pattern: "Include.*SubHabits.*Include.*Tags"
    - from: "src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs"
      to: "src/Orbit.Domain/Models/AiAction.cs"
      via: "IsNegative flag passed through to Habit.Create"
      pattern: "IsNegative"
---

<objective>
Implement all habit-related application logic: sub-habit management (add, remove, log), negative habit support, log notes, updated GetHabits with includes, and AI prompt updates for IsNegative + notes.

Purpose: Delivers requirements HABIT-01 through HABIT-05 (sub-habits, negative habits, log notes) -- the core habit domain extensions.
Output: 4 new command files, updated commands/queries/validators/controller, updated AI prompt and chat handler.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-habit-domain-extensions/02-RESEARCH.md
@.planning/phases/02-habit-domain-extensions/02-01-SUMMARY.md
@src/Orbit.Application/Habits/Commands/CreateHabitCommand.cs
@src/Orbit.Application/Habits/Commands/LogHabitCommand.cs
@src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs
@src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs
@src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs
@src/Orbit.Api/Controllers/HabitsController.cs
@src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
@src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
@src/Orbit.Domain/Models/AiAction.cs
@src/Orbit.Domain/Enums/AiActionType.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sub-habit commands, negative habit + notes updates, and validators</name>
  <files>
    src/Orbit.Application/Habits/Commands/CreateHabitCommand.cs
    src/Orbit.Application/Habits/Commands/LogHabitCommand.cs
    src/Orbit.Application/Habits/Commands/AddSubHabitCommand.cs
    src/Orbit.Application/Habits/Commands/RemoveSubHabitCommand.cs
    src/Orbit.Application/Habits/Commands/LogSubHabitCommand.cs
    src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs
    src/Orbit.Application/Habits/Validators/CreateHabitCommandValidator.cs
    src/Orbit.Application/Habits/Validators/LogHabitCommandValidator.cs
    src/Orbit.Application/Habits/Validators/AddSubHabitCommandValidator.cs
    src/Orbit.Application/Habits/Validators/LogSubHabitCommandValidator.cs
  </files>
  <action>
    **Modify: CreateHabitCommand.cs** -- Add parameters to the record:
    - `bool IsNegative = false`
    - `IReadOnlyList<string>? SubHabits = null` (list of sub-habit titles to create with the parent)
    Update handler: pass `request.IsNegative` to `Habit.Create()`. After creating the habit, if `request.SubHabits` has items, iterate and call `habit.AddSubHabit(title, index)` for each (index = 0-based sort order). Check each result for failure.

    **Modify: LogHabitCommand.cs** -- Add parameter: `string? Note = null`. Update handler: pass `request.Note` to `habit.Log()`. The domain method already accepts note (from Plan 01 entity changes).

    **New: AddSubHabitCommand.cs** -- Record: `AddSubHabitCommand(Guid UserId, Guid HabitId, string Title) : IRequest<Result<Guid>>`. Handler: load habit by ID via `habitRepository.GetByIdAsync()`, verify ownership (habit.UserId == request.UserId), determine next sort order (habit.SubHabits.Count -- NOTE: GetByIdAsync uses FindAsync which tracks, so navigation won't be loaded. Instead, use the new FindAsync with includes: `habitRepository.FindAsync(h => h.Id == request.HabitId, q => q.Include(h => h.SubHabits))`  and take `.FirstOrDefault()`. BUT this uses AsNoTracking so entity won't be tracked. BETTER APPROACH: inject `OrbitDbContext` directly in the handler -- this is acceptable in Clean Architecture when GenericRepository doesn't fit. Use `dbContext.Habits.Include(h => h.SubHabits).FirstOrDefaultAsync(h => h.Id == request.HabitId)` to get tracked entity with sub-habits loaded. Then call `habit.AddSubHabit(request.Title, nextSortOrder)`. Save via unitOfWork. Return sub-habit Id.

    ACTUALLY, simpler approach: The `AddSubHabit` method on Habit creates and adds a SubHabit. The handler just needs to load the habit (GetByIdAsync tracks it via FindAsync), call `habit.AddSubHabit(title, sortOrder)`, and save. The sort order can be passed as 0 (or the handler can count existing sub-habits -- but that requires loading them). For simplicity: accept `int? SortOrder = null` on the command. If null, default to 0. The frontend/caller is responsible for providing sort order if ordering matters. This avoids needing to load all sub-habits just to count them.

    REVISED: `AddSubHabitCommand(Guid UserId, Guid HabitId, string Title, int SortOrder = 0) : IRequest<Result<Guid>>`. Handler loads habit via GetByIdAsync (tracked), calls habit.AddSubHabit(title, sortOrder), saves, returns sub-habit Id.

    **New: RemoveSubHabitCommand.cs** -- Record: `RemoveSubHabitCommand(Guid UserId, Guid HabitId, Guid SubHabitId) : IRequest<Result>`. Handler: load habit via GetByIdAsync, verify ownership, call `habit.RemoveSubHabit(request.SubHabitId)`, save. The domain method deactivates the sub-habit (sets IsActive = false).

    IMPORTANT: RemoveSubHabit needs the sub-habits loaded. Since GetByIdAsync won't load navigation properties, we need a different approach. Options: (1) inject DbContext directly, (2) use FindAsync with includes. Go with option (2): inject `IGenericRepository<Habit>`, call the includes overload: `var habits = await habitRepository.FindAsync(h => h.Id == request.HabitId, q => q.Include(h => h.SubHabits))` -- BUT this returns AsNoTracking entities, so changes won't be saved. SOLUTION: For commands that modify entities with navigation properties, inject `OrbitDbContext` directly. This is the standard EF Core approach when the generic repository's AsNoTracking doesn't work for writes.

    REVISED approach for both AddSubHabitCommand and RemoveSubHabitCommand handlers:
    - Inject `OrbitDbContext` (not generic repository) for these handlers since they need tracked entities with navigation properties loaded.
    - `var habit = await dbContext.Habits.Include(h => h.SubHabits).FirstOrDefaultAsync(h => h.Id == request.HabitId, ct)`
    - Verify habit exists and ownership matches.
    - For Add: `habit.AddSubHabit(title, sortOrder)`, for Remove: `habit.RemoveSubHabit(subHabitId)`.
    - `await dbContext.SaveChangesAsync(ct)` (or inject IUnitOfWork -- both work, but using dbContext.SaveChangesAsync directly is fine since we're already using dbContext).

    **New: LogSubHabitCommand.cs** -- Record: `LogSubHabitCommand(Guid UserId, Guid HabitId, DateOnly Date, IReadOnlyList<SubHabitCompletion> Completions) : IRequest<Result>` where `SubHabitCompletion` is a nested record: `record SubHabitCompletion(Guid SubHabitId, bool IsCompleted)`. This enables batch logging of sub-habit completions per the research recommendation.

    Handler: inject `OrbitDbContext`. Load habit with sub-habits: `dbContext.Habits.Include(h => h.SubHabits).FirstOrDefaultAsync(h => h.Id == request.HabitId)`. Verify ownership. For each completion in request.Completions, verify the sub-habit belongs to this habit (find in habit.SubHabits), then create SubHabitLog via `SubHabitLog.Create(completion.SubHabitId, request.Date, completion.IsCompleted)` and add to `dbContext.SubHabitLogs`. Save via dbContext.SaveChangesAsync.

    **Modify: GetHabitsQuery.cs** -- Update handler to use the new FindAsync overload with includes:
    ```csharp
    return await habitRepository.FindAsync(
        h => h.UserId == request.UserId && h.IsActive,
        q => q.Include(h => h.SubHabits.Where(sh => sh.IsActive).OrderBy(sh => sh.SortOrder))
              .Include(h => h.Tags),
        cancellationToken);
    ```
    This uses the repository's includes overload (AsNoTracking is fine for queries).

    **Modify: CreateHabitCommandValidator.cs** -- Add rules:
    - `RuleFor(x => x.SubHabits).Must(subs => subs is null || subs.Count <= 20).WithMessage("Maximum 20 sub-habits")`
    - `RuleForEach(x => x.SubHabits).NotEmpty().MaximumLength(200).When(x => x.SubHabits is not null)`

    **Modify: LogHabitCommandValidator.cs** -- Add rule:
    - `RuleFor(x => x.Note).MaximumLength(500).When(x => x.Note is not null)`

    **New: AddSubHabitCommandValidator.cs** -- Validate: UserId NotEmpty, HabitId NotEmpty, Title NotEmpty + MaximumLength(200), SortOrder >= 0.

    **New: LogSubHabitCommandValidator.cs** -- Validate: UserId NotEmpty, HabitId NotEmpty, Completions NotEmpty (at least one), each Completion.SubHabitId NotEmpty.
  </action>
  <verify>
    Run `dotnet build src/Orbit.Application/Orbit.Application.csproj` -- must compile with zero errors.
    Verify all 4 new command files exist.
    Verify all validator files exist and compile.
  </verify>
  <done>
    CreateHabitCommand accepts IsNegative + SubHabits. LogHabitCommand accepts Note. AddSubHabitCommand, RemoveSubHabitCommand, and LogSubHabitCommand handle sub-habit lifecycle. GetHabitsQuery includes SubHabits and Tags. All validators enforce constraints.
  </done>
</task>

<task type="auto">
  <name>Task 2: HabitsController endpoints, AI prompt update, and chat handler</name>
  <files>
    src/Orbit.Api/Controllers/HabitsController.cs
    src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
    src/Orbit.Application/Chat/Commands/ProcessUserChatCommand.cs
    src/Orbit.Domain/Models/AiAction.cs
  </files>
  <action>
    **Modify: HabitsController.cs** -- Update existing request records and add new endpoints:

    Update `CreateHabitRequest`: add `bool IsNegative = false` and `IReadOnlyList<string>? SubHabits = null`. Update the `CreateHabit` action to pass these through to `CreateHabitCommand`.

    Update `LogHabitRequest`: add `string? Note = null`. Update the `LogHabit` action to pass Note to `LogHabitCommand`.

    Add new request records:
    - `record AddSubHabitRequest(string Title, int SortOrder = 0)`
    - `record SubHabitCompletionRequest(Guid SubHabitId, bool IsCompleted)`
    - `record LogSubHabitsRequest(DateOnly Date, IReadOnlyList<SubHabitCompletionRequest> Completions)`

    Add new endpoints:

    `POST /api/habits/{id}/sub-habits` -- AddSubHabit:
    ```csharp
    [HttpPost("{id:guid}/sub-habits")]
    public async Task<IActionResult> AddSubHabit(Guid id, [FromBody] AddSubHabitRequest request, CancellationToken ct)
    {
        var command = new AddSubHabitCommand(HttpContext.GetUserId(), id, request.Title, request.SortOrder);
        var result = await mediator.Send(command, ct);
        return result.IsSuccess ? Ok(new { subHabitId = result.Value }) : BadRequest(new { error = result.Error });
    }
    ```

    `DELETE /api/habits/{id}/sub-habits/{subHabitId}` -- RemoveSubHabit:
    ```csharp
    [HttpDelete("{id:guid}/sub-habits/{subHabitId:guid}")]
    public async Task<IActionResult> RemoveSubHabit(Guid id, Guid subHabitId, CancellationToken ct)
    {
        var command = new RemoveSubHabitCommand(HttpContext.GetUserId(), id, subHabitId);
        var result = await mediator.Send(command, ct);
        return result.IsSuccess ? NoContent() : BadRequest(new { error = result.Error });
    }
    ```

    `POST /api/habits/{id}/sub-habits/log` -- LogSubHabits:
    ```csharp
    [HttpPost("{id:guid}/sub-habits/log")]
    public async Task<IActionResult> LogSubHabits(Guid id, [FromBody] LogSubHabitsRequest request, CancellationToken ct)
    {
        var completions = request.Completions.Select(c => new SubHabitCompletion(c.SubHabitId, c.IsCompleted)).ToList();
        var command = new LogSubHabitCommand(HttpContext.GetUserId(), id, request.Date, completions);
        var result = await mediator.Send(command, ct);
        return result.IsSuccess ? Ok() : BadRequest(new { error = result.Error });
    }
    ```

    **Modify: AiAction.cs** -- Add property: `bool? IsNegative { get; init; }` and `string? Note { get; init; }`.

    **Modify: SystemPromptBuilder.cs** -- Minimal Phase 2 updates per research recommendation (full AI features deferred to Phase 3):

    1. In the "What You CAN Do" section, add:
       - "Create and track negative/bad habits (e.g., 'I want to stop smoking', 'I want to quit snacking')"
       - "Add notes when logging habits (e.g., 'I ran 5km today, felt great')"

    2. In the habit listing loop, add IsNegative indicator:
       ```csharp
       var negativeLabel = habit.IsNegative ? " | NEGATIVE (slip-up tracking)" : "";
       sb.AppendLine($"- \"{habit.Title}\" | ID: {habit.Id} | Unit: {typeLabel} | Frequency: {freqLabel}{negativeLabel}");
       ```

    3. In the Action Types section, update:
       - `CreateHabit`: add `isNegative (optional, defaults to false)` to the field list
       - `LogHabit`: add `note (optional, text note)` to the field list

    4. Add an example for negative habit creation:
       ```json
       User: "I want to stop smoking"
       {
         "actions": [
           {
             "type": "CreateHabit",
             "title": "Smoking",
             "habitType": "Boolean",
             "isNegative": true,
             "frequencyUnit": "Day",
             "frequencyQuantity": 1
           }
         ],
         "aiMessage": "Created a habit to track smoking slip-ups. Log each time you smoke and try to reduce over time!"
       }
       ```

    5. Add an example for logging with a note:
       ```json
       User: "I ran 5km today, felt amazing"
       {
         "actions": [
           {
             "type": "LogHabit",
             "habitId": "...",
             "value": 5,
             "note": "Felt amazing"
           }
         ],
         "aiMessage": "Logged 5km for your running habit with your note!"
       }
       ```

    **Modify: ProcessUserChatCommand.cs** -- Update `ExecuteCreateHabitAsync` to pass `action.IsNegative ?? false` to `Habit.Create()`. Update `ExecuteLogHabitAsync` to pass `action.Note` to `habit.Log()`.
  </action>
  <verify>
    Run `dotnet build Orbit.slnx` -- must compile with zero errors across the entire solution.
    Verify HabitsController has 3 new endpoints (AddSubHabit, RemoveSubHabit, LogSubHabits).
    Verify AiAction has IsNegative and Note properties.
    Verify SystemPromptBuilder contains "isNegative" and "note" field references.
    Verify ProcessUserChatCommand passes IsNegative and Note through.
  </verify>
  <done>
    HabitsController exposes sub-habit management (POST add, DELETE remove, POST log) plus updated create (IsNegative, SubHabits) and log (Note) endpoints. AI prompt teaches LLM about IsNegative and Note fields. Chat handler passes new fields through to domain methods.
  </done>
</task>

</tasks>

<verification>
- `dotnet build Orbit.slnx` compiles with zero errors
- POST /api/habits accepts IsNegative and SubHabits parameters
- POST /api/habits/{id}/log accepts Note parameter
- POST /api/habits/{id}/sub-habits endpoint exists
- DELETE /api/habits/{id}/sub-habits/{subId} endpoint exists
- POST /api/habits/{id}/sub-habits/log endpoint exists
- GetHabitsQuery handler uses FindAsync with Include(SubHabits).Include(Tags)
- SystemPromptBuilder references isNegative and note fields
- ProcessUserChatCommand passes IsNegative to Habit.Create and Note to habit.Log
</verification>

<success_criteria>
- All habit-related requirements (HABIT-01 through HABIT-05) have working API endpoints
- Sub-habit CRUD: create with parent, add to existing, remove (deactivate), log completions
- Negative habits: IsNegative flag on create, multiple logs per day for boolean negatives
- Notes: Optional note on any habit log
- AI prompt updated for IsNegative and Note (sub-habits and tags deferred to Phase 3 per AI-02/AI-03)
- Solution builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-habit-domain-extensions/02-02-SUMMARY.md`
</output>
