---
phase: 07-routine-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Orbit.Domain/Models/RoutineAnalysis.cs
  - src/Orbit.Domain/Interfaces/IRoutineAnalysisService.cs
  - src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs
  - src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
  - src/Orbit.Api/Program.cs
autonomous: true

must_haves:
  truths:
    - "IRoutineAnalysisService can analyze a user's habit log timestamps and return routine patterns with confidence scores"
    - "GeminiRoutineAnalysisService converts UTC timestamps to user's local time before sending to Gemini"
    - "Pattern detection requires minimum 7 days of data, returns empty patterns otherwise"
    - "Time slot suggestions return exactly 3 options with scores and rationales"
    - "Routine patterns are included in AI system prompt as context for personalized responses"
  artifacts:
    - path: "src/Orbit.Domain/Models/RoutineAnalysis.cs"
      provides: "RoutineAnalysis, RoutinePattern, TimeBlock, ConflictWarning, ConflictingHabit, TimeSlotSuggestion records"
      contains: "RoutineAnalysis"
    - path: "src/Orbit.Domain/Interfaces/IRoutineAnalysisService.cs"
      provides: "IRoutineAnalysisService interface with AnalyzeRoutinesAsync, DetectConflictsAsync, SuggestTimeSlotsAsync"
      contains: "IRoutineAnalysisService"
    - path: "src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs"
      provides: "Gemini-powered implementation of IRoutineAnalysisService"
      contains: "GeminiRoutineAnalysisService"
  key_links:
    - from: "src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs"
      to: "src/Orbit.Domain/Interfaces/IRoutineAnalysisService.cs"
      via: "implements interface"
      pattern: "IRoutineAnalysisService"
    - from: "src/Orbit.Api/Program.cs"
      to: "src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs"
      via: "DI registration"
      pattern: "AddHttpClient.*IRoutineAnalysisService.*GeminiRoutineAnalysisService"
    - from: "src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs"
      to: "src/Orbit.Domain/Models/RoutineAnalysis.cs"
      via: "accepts routine patterns parameter"
      pattern: "IReadOnlyList<RoutinePattern>"
---

<objective>
Create the routine analysis domain models, service interface, Gemini-powered implementation, and integrate routine context into the AI system prompt.

Purpose: Establish the core routine intelligence infrastructure that detects time-of-day patterns from habit logs, generates confidence scores, suggests time slots in triple-choice format, and feeds routine context into the AI for personalized responses.

Output: Domain models, IRoutineAnalysisService interface, GeminiRoutineAnalysisService implementation, updated SystemPromptBuilder with routine context, DI wiring.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-routine-intelligence/07-RESEARCH.md
@src/Orbit.Domain/Interfaces/IFactExtractionService.cs
@src/Orbit.Infrastructure/Services/GeminiFactExtractionService.cs
@src/Orbit.Infrastructure/Services/GeminiIntentService.cs
@src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
@src/Orbit.Domain/Entities/HabitLog.cs
@src/Orbit.Domain/Entities/UserFact.cs
@src/Orbit.Domain/Entities/User.cs
@src/Orbit.Domain/Interfaces/IGenericRepository.cs
@src/Orbit.Infrastructure/Configuration/GeminiSettings.cs
@src/Orbit.Api/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain models and IRoutineAnalysisService interface</name>
  <files>
    src/Orbit.Domain/Models/RoutineAnalysis.cs
    src/Orbit.Domain/Interfaces/IRoutineAnalysisService.cs
  </files>
  <action>
    **Create `src/Orbit.Domain/Models/RoutineAnalysis.cs`** with ALL routine intelligence models in one file (follows existing pattern where AiActionPlan.cs contains related records):

    ```csharp
    namespace Orbit.Domain.Models;

    public record RoutineAnalysis
    {
        public required IReadOnlyList<RoutinePattern> Patterns { get; init; }
    }

    public record RoutinePattern
    {
        public required Guid HabitId { get; init; }
        public required string HabitTitle { get; init; }
        public required string Description { get; init; }  // "user typically logs this Mon/Wed/Fri around 7:00 AM"
        public required decimal ConsistencyScore { get; init; }  // 0.0 - 1.0
        public required string Confidence { get; init; }  // "HIGH" | "MEDIUM" | "LOW"
        public required IReadOnlyList<TimeBlock> TimeBlocks { get; init; }
    }

    public record TimeBlock
    {
        public required DayOfWeek DayOfWeek { get; init; }
        public required int StartHour { get; init; }  // 0-23 (user's local timezone)
        public required int EndHour { get; init; }
    }

    public record ConflictWarning
    {
        public required bool HasConflict { get; init; }
        public required IReadOnlyList<ConflictingHabit> ConflictingHabits { get; init; }
        public required string Severity { get; init; }  // "HIGH" | "MEDIUM" | "LOW"
        public required string? Recommendation { get; init; }
    }

    public record ConflictingHabit
    {
        public required Guid HabitId { get; init; }
        public required string HabitTitle { get; init; }
        public required string ConflictDescription { get; init; }
    }

    public record TimeSlotSuggestion
    {
        public required string Description { get; init; }  // "Tuesday/Thursday mornings (8-9 AM)"
        public required IReadOnlyList<TimeBlock> TimeBlocks { get; init; }
        public required string Rationale { get; init; }
        public required decimal Score { get; init; }  // 0.0 - 1.0
    }
    ```

    **Create `src/Orbit.Domain/Interfaces/IRoutineAnalysisService.cs`** following the existing pattern of IFactExtractionService / IAiIntentService:

    ```csharp
    using Orbit.Domain.Common;
    using Orbit.Domain.Enums;
    using Orbit.Domain.Models;

    namespace Orbit.Domain.Interfaces;

    public interface IRoutineAnalysisService
    {
        Task<Result<RoutineAnalysis>> AnalyzeRoutinesAsync(
            Guid userId,
            CancellationToken cancellationToken = default);

        Task<Result<ConflictWarning?>> DetectConflictsAsync(
            Guid userId,
            FrequencyUnit? frequencyUnit,
            int? frequencyQuantity,
            IReadOnlyList<DayOfWeek>? days,
            CancellationToken cancellationToken = default);

        Task<Result<IReadOnlyList<TimeSlotSuggestion>>> SuggestTimeSlotsAsync(
            Guid userId,
            string habitTitle,
            FrequencyUnit? frequencyUnit,
            int? frequencyQuantity,
            CancellationToken cancellationToken = default);
    }
    ```

    Note: `SuggestTimeSlotsAsync` takes `habitTitle` parameter so Gemini can provide contextual suggestions.
  </action>
  <verify>
    Run `dotnet build src/Orbit.Domain/` to confirm models and interface compile. Verify no build errors.
  </verify>
  <done>
    RoutineAnalysis.cs contains 6 record types (RoutineAnalysis, RoutinePattern, TimeBlock, ConflictWarning, ConflictingHabit, TimeSlotSuggestion). IRoutineAnalysisService.cs has 3 methods: AnalyzeRoutinesAsync, DetectConflictsAsync, SuggestTimeSlotsAsync.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GeminiRoutineAnalysisService, update SystemPromptBuilder, and wire DI</name>
  <files>
    src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs
    src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs
    src/Orbit.Api/Program.cs
  </files>
  <action>
    **Create `src/Orbit.Infrastructure/Services/GeminiRoutineAnalysisService.cs`** following the EXACT same pattern as GeminiFactExtractionService (primary constructor, IOptions&lt;GeminiSettings&gt;, ILogger, private Gemini API DTOs, retry logic with exponential backoff for rate limiting):

    Constructor dependencies: `HttpClient httpClient, IOptions<GeminiSettings> options, IGenericRepository<User> userRepository, IGenericRepository<Habit> habitRepository, IGenericRepository<HabitLog> habitLogRepository, ILogger<GeminiRoutineAnalysisService> logger`

    Constants:
    - `MinDaysForPatternDetection = 7`
    - `AnalysisWindowDays = 60`
    - `MinLogsPerHabit = 5`

    **AnalyzeRoutinesAsync implementation:**
    1. Load user by userId for TimeZone
    2. Load habit logs from last 60 days: `l => l.CreatedAtUtc >= DateTime.UtcNow.AddDays(-AnalysisWindowDays)` — then filter by user's habits in memory (HabitLog has no UserId, so load user's habits first, collect habitIds, then filter logs by those habitIds)
    3. Return empty patterns if no logs or if `(DateTime.UtcNow - logs.Min(l => l.CreatedAtUtc)).Days < MinDaysForPatternDetection`
    4. Load habits for titles
    5. Convert CreatedAtUtc to user's local time using `TimeZoneInfo.ConvertTimeFromUtc(log.CreatedAtUtc, TimeZoneInfo.FindSystemTimeZoneById(user.TimeZone))`
    6. Filter habits with fewer than MinLogsPerHabit logs
    7. Build Gemini prompt requesting JSON with patterns array (see research doc Pattern 1 for exact prompt structure)
    8. Call Gemini API, deserialize response as RoutineAnalysis
    9. Use `$$"""` raw string literals for prompts containing JSON (C# raw string literal gotcha from MEMORY.md)

    **DetectConflictsAsync implementation:**
    1. Call AnalyzeRoutinesAsync first to get current patterns
    2. If no patterns (insufficient data), return `Result.Success<ConflictWarning?>(null)` — no conflict warning when no data
    3. Build Gemini prompt with new habit's frequency/days and existing patterns, requesting ConflictWarning JSON (see research doc Pattern 2)
    4. Call Gemini, deserialize as ConflictWarning
    5. If `hasConflict` is false, return null (no warning needed)

    **SuggestTimeSlotsAsync implementation:**
    1. Call AnalyzeRoutinesAsync first to get current patterns
    2. If no patterns, return 3 generic time slot suggestions (morning 7-8 AM, afternoon 12-1 PM, evening 6-7 PM) as fallback with low scores and "No routine data yet" rationale
    3. Build Gemini prompt requesting EXACTLY 3 suggestions with diversity constraint (see research doc Pattern 3)
    4. Call Gemini, deserialize as wrapper object with `suggestions` array
    5. Ensure exactly 3 suggestions returned, sorted by score descending

    **Gemini API DTOs:** Use private records identical to GeminiFactExtractionService (GeminiRequest, GeminiContent, GeminiPart, GeminiGenerationConfig, GeminiResponse, GeminiCandidate). Add `private static readonly JsonSerializerOptions` with `PropertyNameCaseInsensitive = true` and `JsonStringEnumConverter()`.

    **Add a shared `CallGeminiAsync<T>` private method** that encapsulates: build URL, POST with retry logic (max 3 retries, exponential backoff 2s/4s/8s for 429 responses), deserialize response text, return `Result<T>`.

    **Update `src/Orbit.Infrastructure/Services/SystemPromptBuilder.cs`:**
    Add a new optional parameter to `BuildSystemPrompt`: `IReadOnlyList<RoutinePattern>? routinePatterns = null`

    After the "What You Know About This User" section and before "Today's Date", add a new section:

    ```
    ## Your Understanding of This User's Routine

    If routinePatterns is null or empty:
    "(no routine patterns detected yet)"

    Otherwise, list each pattern:
    - "{habit.HabitTitle}": {habit.Description} (confidence: {habit.Confidence}, consistency: {habit.ConsistencyScore:P0})

    Then add instruction text:
    "Use these routine patterns to:
    - Warn about potential scheduling conflicts when user creates new habits
    - Suggest optimal time slots when asked
    - Personalize scheduling advice based on detected patterns"
    ```

    IMPORTANT: The existing `BuildSystemPrompt` call sites (GeminiIntentService, OllamaIntentService) do NOT pass routinePatterns yet — that happens in Plan 02. The default `null` parameter means existing behavior is unchanged.

    **Update `src/Orbit.Api/Program.cs`:**
    Add DI registration for IRoutineAnalysisService AFTER the fact extraction registration line (line ~90):
    ```csharp
    // Routine analysis always uses Gemini (structured output reliability)
    builder.Services.AddHttpClient<IRoutineAnalysisService, GeminiRoutineAnalysisService>();
    ```

    This follows the same pattern as IFactExtractionService — always uses Gemini regardless of AiProvider setting, because routine analysis requires reliable structured JSON output.
  </action>
  <verify>
    Run `dotnet build` from solution root to confirm all projects compile. Verify GeminiRoutineAnalysisService implements all 3 interface methods. Verify SystemPromptBuilder signature has new optional parameter. Verify Program.cs has IRoutineAnalysisService registration.
  </verify>
  <done>
    GeminiRoutineAnalysisService implements AnalyzeRoutinesAsync (pattern detection with UTC->local conversion, 7-day minimum, 60-day window), DetectConflictsAsync (conflict warning with severity levels), SuggestTimeSlotsAsync (triple-choice with diversity). SystemPromptBuilder accepts optional routinePatterns parameter. DI registered in Program.cs. Full solution builds cleanly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Orbit.slnx` compiles with no errors
2. IRoutineAnalysisService interface exists with 3 methods
3. GeminiRoutineAnalysisService implements all 3 methods
4. SystemPromptBuilder.BuildSystemPrompt has `IReadOnlyList<RoutinePattern>? routinePatterns = null` parameter
5. Program.cs registers `IRoutineAnalysisService` via `AddHttpClient`
6. Existing tests still pass (no breaking changes — new parameter is optional)
</verification>

<success_criteria>
- Domain models compile and contain all 6 record types for routine intelligence
- IRoutineAnalysisService has AnalyzeRoutinesAsync, DetectConflictsAsync, SuggestTimeSlotsAsync
- GeminiRoutineAnalysisService converts UTC->local time, enforces minimum data thresholds, uses Gemini with retry logic
- SystemPromptBuilder optionally includes routine patterns section
- DI wiring complete — IRoutineAnalysisService resolves to GeminiRoutineAnalysisService
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-routine-intelligence/07-01-SUMMARY.md`
</output>
