---
phase: 03-metrics-and-ai-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Orbit.Domain/Models/HabitMetrics.cs
  - src/Orbit.Domain/Models/HabitTrend.cs
  - src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs
  - src/Orbit.Application/Habits/Queries/GetHabitTrendQuery.cs
  - src/Orbit.Api/Controllers/HabitsController.cs
autonomous: true

must_haves:
  truths:
    - "User can see current streak and longest streak for any habit (frequency-aware, timezone-aware)"
    - "User can see weekly and monthly completion rates for any habit"
    - "User can see progress trends over time for quantifiable habits"
  artifacts:
    - path: "src/Orbit.Domain/Models/HabitMetrics.cs"
      provides: "DTO for streak and completion rate data"
      contains: "CurrentStreak"
    - path: "src/Orbit.Domain/Models/HabitTrend.cs"
      provides: "DTO for time-series trend data"
      contains: "TrendPoint"
    - path: "src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs"
      provides: "Query handler with frequency-aware streak calculation and completion rates"
      exports: ["GetHabitMetricsQuery", "GetHabitMetricsQueryHandler"]
    - path: "src/Orbit.Application/Habits/Queries/GetHabitTrendQuery.cs"
      provides: "Query handler with weekly/monthly trend aggregation for quantifiable habits"
      exports: ["GetHabitTrendQuery", "GetHabitTrendQueryHandler"]
    - path: "src/Orbit.Api/Controllers/HabitsController.cs"
      provides: "GET /api/habits/{id}/metrics and GET /api/habits/{id}/trends endpoints"
      contains: "GetMetrics"
  key_links:
    - from: "src/Orbit.Api/Controllers/HabitsController.cs"
      to: "src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs"
      via: "mediator.Send(new GetHabitMetricsQuery(...))"
      pattern: "new GetHabitMetricsQuery"
    - from: "src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs"
      to: "src/Orbit.Domain/Entities/Habit.cs"
      via: "habitRepository.FindAsync with Include(Logs)"
      pattern: "Include.*Logs"
    - from: "src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs"
      to: "src/Orbit.Domain/Entities/User.cs"
      via: "userRepository.GetByIdAsync for timezone"
      pattern: "user\\.TimeZone"
---

<objective>
Implement habit metrics: frequency-aware streaks, completion rates, and quantifiable habit trends.

Purpose: Satisfies METR-01 (streaks), METR-02 (completion rates), METR-03 (trends) -- users can see measurable progress for their habits.
Output: Two new query handlers, two DTOs, and two API endpoints on HabitsController.
</objective>

<execution_context>
@C:\Users\thoma\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\thoma\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-metrics-and-ai-enhancement/03-RESEARCH.md
@src/Orbit.Domain/Entities/Habit.cs
@src/Orbit.Domain/Entities/HabitLog.cs
@src/Orbit.Domain/Entities/User.cs
@src/Orbit.Domain/Enums/FrequencyUnit.cs
@src/Orbit.Domain/Interfaces/IGenericRepository.cs
@src/Orbit.Application/Habits/Queries/GetHabitsQuery.cs
@src/Orbit.Api/Controllers/HabitsController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DTOs and GetHabitMetricsQuery with frequency-aware streaks and completion rates</name>
  <files>
    src/Orbit.Domain/Models/HabitMetrics.cs
    src/Orbit.Domain/Models/HabitTrend.cs
    src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs
  </files>
  <action>
    **1. Create `src/Orbit.Domain/Models/HabitMetrics.cs`:**
    Record with: `int CurrentStreak`, `int LongestStreak`, `decimal WeeklyCompletionRate` (percentage 0-100), `decimal MonthlyCompletionRate` (percentage 0-100), `int TotalCompletions`, `DateOnly? LastCompletedDate`.

    **2. Create `src/Orbit.Domain/Models/HabitTrend.cs`:**
    Record `TrendPoint` with: `string Period` (e.g., "2026-02", "2026-W06"), `decimal Average`, `decimal Minimum`, `decimal Maximum`, `int Count`.
    Record `HabitTrend` with: `IReadOnlyList<TrendPoint> Weekly`, `IReadOnlyList<TrendPoint> Monthly`.

    **3. Create `src/Orbit.Application/Habits/Queries/GetHabitMetricsQuery.cs`:**
    Record: `GetHabitMetricsQuery(Guid UserId, Guid HabitId) : IRequest<Result<HabitMetrics>>`

    Handler injects `IGenericRepository<Habit>` and `IGenericRepository<User>`.

    Handler logic:
    a) Load habit with logs: `habitRepository.FindAsync(h => h.Id == request.HabitId && h.UserId == request.UserId && h.IsActive, q => q.Include(h => h.Logs), ct)`. Return failure if not found.
    b) Load user: `userRepository.GetByIdAsync(request.UserId, ct)`. Return failure if not found.
    c) Calculate user's "today": `TimeZoneInfo.FindSystemTimeZoneById(user.TimeZone ?? "UTC")`, then `TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, tz)`, then `DateOnly.FromDateTime(...)`.
    d) Build `HashSet<DateOnly>` from `habit.Logs.Select(l => l.Date).Distinct()` -- distinct dates handles negative habits with multiple daily logs.
    e) Generate expected dates backwards from today using frequency-aware logic:
       - If `habit.Days.Count > 0 && habit.FrequencyQuantity == 1`: iterate backwards day by day, only include dates whose DayOfWeek matches any in `habit.Days`. Stop after 365 iterations.
       - Else: start from today, subtract the frequency period each step. `FrequencyUnit.Day` -> `AddDays(-FrequencyQuantity)`, `Week` -> `AddDays(-7 * FrequencyQuantity)`, `Month` -> `AddMonths(-FrequencyQuantity)`, `Year` -> `AddYears(-FrequencyQuantity)`. Stop after 365 iterations or when date is before `habit.CreatedAtUtc` (converted to DateOnly).
    f) **Current streak**: iterate expected dates from most recent. For POSITIVE habits: count consecutive dates present in logDates HashSet, break on first miss. For NEGATIVE habits (`habit.IsNegative`): count consecutive dates NOT present in logDates, break on first hit. Note: today might not be in logDates yet -- if today is an expected date and it is not in logDates, for positive habits the streak is 0 (hasn't been done yet today) UNLESS there are no expected dates for today (i.e., today isn't an expected date, in which case start counting from the most recent expected date before today).
    g) **Longest streak**: scan ALL expected dates (since habit creation), using same positive/negative logic, track max consecutive run.
    h) **Weekly completion rate**: generate expected dates in range `[today.AddDays(-7), today]`, count how many are in logDates, return percentage. For negative habits, invert: count expected dates NOT in logDates as "successes".
    i) **Monthly completion rate**: same but `[today.AddMonths(-1), today]`.
    j) **TotalCompletions**: `logDates.Count`. **LastCompletedDate**: `logDates.Max()` or null if empty.
    k) Return `Result.Success(new HabitMetrics(...))`.

    IMPORTANT: Extract the expected-date generation and streak calculation into private methods to keep the handler readable. The expected-date generator should also be reusable by the completion rate calculation.
  </action>
  <verify>
    `dotnet build src/Orbit.Application/Orbit.Application.csproj` compiles with zero errors.
  </verify>
  <done>
    HabitMetrics and HabitTrend DTOs exist. GetHabitMetricsQuery handler calculates frequency-aware streaks (positive and negative), weekly/monthly completion rates, with timezone-aware "today".
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GetHabitTrendQuery and add metrics/trends endpoints to HabitsController</name>
  <files>
    src/Orbit.Application/Habits/Queries/GetHabitTrendQuery.cs
    src/Orbit.Api/Controllers/HabitsController.cs
  </files>
  <action>
    **1. Create `src/Orbit.Application/Habits/Queries/GetHabitTrendQuery.cs`:**
    Record: `GetHabitTrendQuery(Guid UserId, Guid HabitId) : IRequest<Result<HabitTrend>>`

    Handler injects `IGenericRepository<Habit>`.

    Handler logic:
    a) Load habit with logs (same Include pattern as GetHabitMetricsQuery).
    b) Return failure if not found or habit.Type is not Quantifiable (trends are for quantifiable habits only -- return `Result.Failure("Trends are only available for quantifiable habits.")`).
    c) Filter logs to last 12 months: `var cutoff = DateOnly.FromDateTime(DateTime.UtcNow).AddMonths(-12); var recentLogs = habit.Logs.Where(l => l.Date >= cutoff).ToList();`
    d) **Weekly aggregation**: Group logs by ISO week using `CultureInfo.InvariantCulture.Calendar.GetWeekOfYear(l.Date.ToDateTime(TimeOnly.MinValue), CalendarWeekRule.FirstDay, DayOfWeek.Monday)`. Project to `TrendPoint` with `Period = $"{year}-W{week:00}"`, Average, Minimum, Maximum of `l.Value`, Count. Order by Period.
    e) **Monthly aggregation**: Group by `new { l.Date.Year, l.Date.Month }`. Project to `TrendPoint` with `Period = $"{year}-{month:00}"`. Order by Period.
    f) Return `Result.Success(new HabitTrend(weekly, monthly))`.

    **2. Add two endpoints to `src/Orbit.Api/Controllers/HabitsController.cs`:**

    Add AFTER the existing `DeleteHabit` endpoint:

    ```csharp
    [HttpGet("{id:guid}/metrics")]
    public async Task<IActionResult> GetMetrics(Guid id, CancellationToken cancellationToken)
    {
        var query = new GetHabitMetricsQuery(HttpContext.GetUserId(), id);
        var result = await mediator.Send(query, cancellationToken);
        return result.IsSuccess ? Ok(result.Value) : BadRequest(new { error = result.Error });
    }

    [HttpGet("{id:guid}/trends")]
    public async Task<IActionResult> GetTrends(Guid id, CancellationToken cancellationToken)
    {
        var query = new GetHabitTrendQuery(HttpContext.GetUserId(), id);
        var result = await mediator.Send(query, cancellationToken);
        return result.IsSuccess ? Ok(result.Value) : BadRequest(new { error = result.Error });
    }
    ```

    Add the `using` statements for the new query types at the top of the controller file.
  </action>
  <verify>
    `dotnet build src/Orbit.Api/Orbit.Api.csproj` compiles with zero errors.
  </verify>
  <done>
    GET /api/habits/{id}/metrics returns streaks and completion rates. GET /api/habits/{id}/trends returns weekly and monthly aggregated trend data for quantifiable habits. Both endpoints wire through MediatR to their query handlers.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` -- entire solution compiles with zero errors
2. Endpoints visible in Scalar UI at `/scalar/v1` under Habits section
3. `GET /api/habits/{id}/metrics` returns JSON with `currentStreak`, `longestStreak`, `weeklyCompletionRate`, `monthlyCompletionRate`
4. `GET /api/habits/{id}/trends` returns JSON with `weekly` and `monthly` arrays of trend points (or 400 error for boolean habits)
</verification>

<success_criteria>
- HabitMetrics DTO has CurrentStreak, LongestStreak, WeeklyCompletionRate, MonthlyCompletionRate fields
- GetHabitMetricsQuery handler implements frequency-aware streak logic accounting for FrequencyUnit, FrequencyQuantity, Days, IsNegative
- GetHabitMetricsQuery uses User.TimeZone (defaults to UTC) for determining "today"
- GetHabitTrendQuery handler aggregates quantifiable habit logs into weekly and monthly time series
- HabitsController exposes GET metrics and GET trends endpoints
- Solution builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-metrics-and-ai-enhancement/03-01-SUMMARY.md`
</output>
